{"kt_path": "remisultan__multiarm-bandit-algorithm-kotlin__ead934d/core-bandit/src/main/kotlin/org/rsultan/bandit/algorithms/BanditAlgorithm.kt", "Qwen2.5-Coder-1.5B-Instruct": "interface BanditAlgorithm {\n    fun selectArm(): Int\n\n    fun update(reward: Int, value: Float)\n}"}
{"kt_path": "n81ur3__kotlin-coding-challenges__fdc5941/src/main/kotlin/adventofcode2018/Day22ModeMaze.kt", "Qwen2.5-Coder-1.5B-Instruct": "class Day22ModeMaze {\n    constructor()\n}"}
{"kt_path": "n81ur3__kotlin-coding-challenges__fdc5941/src/main/kotlin/adventofcode2017/Day21FractalArt.kt", "Qwen2.5-Coder-1.5B-Instruct": "class Day21FractalArt {\n    constructor()\n}"}
{"kt_path": "n81ur3__kotlin-coding-challenges__fdc5941/src/main/kotlin/adventofcode2017/Day03SpiralMemory.kt", "Qwen2.5-Coder-1.5B-Instruct": "class Day03SpiralMemory {\n    constructor()\n}"}
{"kt_path": "n81ur3__kotlin-coding-challenges__fdc5941/src/main/kotlin/adventofcode2019/Day03CrossedWires.kt", "Qwen2.5-Coder-1.5B-Instruct": "class Day03CrossedWires {\n    constructor()\n}"}
{"kt_path": "n81ur3__kotlin-coding-challenges__fdc5941/src/main/kotlin/adventofcode2018/Day04ReposeRecord.kt", "Qwen2.5-Coder-1.5B-Instruct": "class Day04ReposeRecord {\n    constructor()\n}"}
{"kt_path": "n81ur3__kotlin-coding-challenges__fdc5941/src/main/kotlin/adventofcode2017/Day08LikeRegisters.kt", "Qwen2.5-Coder-1.5B-Instruct": "class Day08LikeRegisters {\n    constructor()\n}"}
{"kt_path": "n81ur3__kotlin-coding-challenges__fdc5941/src/main/kotlin/adventofcode2018/Day11ChronalCharge.kt", "Qwen2.5-Coder-1.5B-Instruct": "class Day11ChronalCharge {\n    constructor()\n}"}
{"kt_path": "n81ur3__kotlin-coding-challenges__fdc5941/src/main/kotlin/adventofcode2020/Day19MonsterMessage.kt", "Qwen2.5-Coder-1.5B-Instruct": "class Day19MonsterMessage {\n    constructor()\n}"}
{"kt_path": "n81ur3__kotlin-coding-challenges__fdc5941/src/main/kotlin/adventofcode2017/Day07RecursiveCircus.kt", "Qwen2.5-Coder-1.5B-Instruct": "class Day07RecursiveCircus {\n    constructor()\n}"}
{"kt_path": "n81ur3__kotlin-coding-challenges__fdc5941/src/main/kotlin/adventofcode2019/Day12TheNbodyProblem.kt", "Qwen2.5-Coder-1.5B-Instruct": "class Day12TheNbodyProblem {\n    constructor()\n}"}
{"kt_path": "n81ur3__kotlin-coding-challenges__fdc5941/src/main/kotlin/adventofcode2018/Day15BeverageBandits.kt", "Qwen2.5-Coder-1.5B-Instruct": "class Day15BeverageBandits {\n    constructor()\n}"}
{"kt_path": "n81ur3__kotlin-coding-challenges__fdc5941/src/main/kotlin/adventofcode2020/Day07HandyHaversacks.kt", "Qwen2.5-Coder-1.5B-Instruct": "class Day07HandyHaversacks {\n    constructor()\n}"}
{"kt_path": "n81ur3__kotlin-coding-challenges__fdc5941/src/main/kotlin/adventofcode2018/Day07TheSumOfItsParts.kt", "Qwen2.5-Coder-1.5B-Instruct": "class Adventofcode2018.Day07TheSumOfItsParts {\n    constructor()\n}"}
{"kt_path": "n81ur3__kotlin-coding-challenges__fdc5941/src/main/kotlin/adventofcode2017/Day25TheHaltingProblem.kt", "Qwen2.5-Coder-1.5B-Instruct": "class Day25TheHaltingProblem {\n    constructor()\n}"}
{"kt_path": "n81ur3__kotlin-coding-challenges__fdc5941/src/main/kotlin/adventofcode2019/Day06UniversalOrbitMap.kt", "Qwen2.5-Coder-1.5B-Instruct": "class Day06UniversalOrbitMap {\n    constructor()\n}"}
{"kt_path": "n81ur3__kotlin-coding-challenges__fdc5941/src/main/kotlin/adventofcode2019/Day10MonitoringStation.kt", "Qwen2.5-Coder-1.5B-Instruct": "class Day10MonitoringStation {\n    constructor()\n}"}
{"kt_path": "n81ur3__kotlin-coding-challenges__fdc5941/src/main/kotlin/adventofcode2018/Day06ChronalCoordinates.kt", "Qwen2.5-Coder-1.5B-Instruct": "class AdventOfCode2018.Day06ChronalCoordinates {\n    constructor()\n}"}
{"kt_path": "n81ur3__kotlin-coding-challenges__fdc5941/src/main/kotlin/adventofcode2020/Day21AllergenAssessment.kt", "Qwen2.5-Coder-1.5B-Instruct": "class AdventOfCode2020Day21AllergenAssessment {\n    constructor()\n}"}
{"kt_path": "n81ur3__kotlin-coding-challenges__fdc5941/src/main/kotlin/adventofcode2017/Day24ElectromagneticMoat.kt", "Qwen2.5-Coder-1.5B-Instruct": "class AdventOfCode2017.Day24ElectromagneticMoat {\n    constructor()\n}"}
{"kt_path": "n81ur3__kotlin-coding-challenges__fdc5941/src/main/kotlin/adventofcode2018/Day12SubterraneanSustainability.kt", "Qwen2.5-Coder-1.5B-Instruct": "class Day12SubterraneanSustainability {\n    constructor()\n}"}
{"kt_path": "n81ur3__kotlin-coding-challenges__fdc5941/src/main/kotlin/adventofcode2018/Day23ExperimentalEmergencyTeleportation.kt", "Qwen2.5-Coder-1.5B-Instruct": "class Day23ExperimentalEmergencyTeleportation {\n    constructor()\n}"}
{"kt_path": "alebedev__aoc2022__d6ba46b/src/main/kotlin/Map.kt", "Qwen2.5-Coder-1.5B-Instruct": "object AocMap {\n    val INSTANCE = AocMap()\n\n    fun solve(): Unit = println(\"Solving...\")\n}\n\nfun main(args: Array<String>) {\n    AocMap.INSTANCE.main()\n}"}
{"kt_path": "andrewrlee__adventOfCode2020__a9c21a6/src/main/kotlin/File09.kt", "Qwen2.5-Coder-1.5B-Instruct": "fun main() {\n    val challenge09 = Challenge09()\n    challenge09.solve()\n}\n\nclass Challenge09 {\n    fun solve() {\n        println(\"Hello, World!\")\n    }\n}"}
{"kt_path": "andrewrlee__adventOfCode2020__a9c21a6/src/main/kotlin/File08.kt", "Qwen2.5-Coder-1.5B-Instruct": "fun main() {\n    val challenge08 = Challenge08()\n    challenge08.solve()\n}\n\nclass Challenge08 {\n    fun solve() {\n        println(\"Hello, World!\")\n    }\n}"}
{"kt_path": "andrewrlee__adventOfCode2020__a9c21a6/src/main/kotlin/File02.kt", "Qwen2.5-Coder-1.5B-Instruct": "fun main() {\n    val challenge02 = Challenge02()\n    challenge02.solve()\n}\n\nclass Challenge02 {\n    fun solve() {\n        println(\"Hello, World!\")\n    }\n}"}
{"kt_path": "andrewrlee__adventOfCode2020__a9c21a6/src/main/kotlin/File07.kt", "Qwen2.5-Coder-1.5B-Instruct": "fun main() {\n    val challenge07 = Challenge07()\n    challenge07.solve()\n}\n\nclass Challenge07 {\n    fun solve() {\n        println(\"Hello, World!\")\n    }\n}"}
{"kt_path": "charlesfranciscodev__codingame__3ec8060/puzzles/kotlin/src/war/war.kt", "Qwen2.5-Coder-1.5B-Instruct": "fun main(args: Array<String>) {\n    val game = Game()\n    game.play()\n}\n\nclass Game {\n    fun play() {\n        println(\"Game is playing!\")\n    }\n}"}
{"kt_path": "al-volkov__spbu_2020_kotlin_homeworks__5049681/src/main/kotlin/homework_5/Task1.kt", "Qwen2.5-Coder-1.5B-Instruct": "fun isNumber(input: String): Boolean {\n    val trimmedInput = input.trim()\n    return when (trimmedInput) {\n        null -> false\n        \"\" -> false\n        else -> try {\n            Integer.parseInt(trimmedInput)\n            true\n        } catch (e: NumberFormatException) {\n            false\n        }\n    }\n}"}
{"kt_path": "iafsilva__codility-lessons__5d86aef/src/main/kotlin/lesson3/FrogJmp.kt", "Qwen2.5-Coder-1.5B-Instruct": "class FrogJmp {\n    fun solution(a: Int, b: Int, c: Int): Int {\n        val difference = b - a\n        val quotient = difference / c\n        val remainder = difference % c\n\n        if (remainder != 0) {\n            return quotient + 1\n        } else {\n            return quotient\n        }\n    }\n}"}
{"kt_path": "mikhalchenko-alexander__advent-of-kotlin-2018-week1__c483ade/src/main/kotlin/com/anahoret/pathfinding/MarkingWayOnMap.kt", "Qwen2.5-Coder-1.5B-Instruct": "package com.anahoret.pathfinding\n\nimport kotlin.jvm.internal.Intrinsics.checkNotNullParameter\n\nclass Graph {\n    companion object {\n        val INSTANCE = Graph()\n    }\n\n    fun getMapWithPath(path: String): String {\n        checkNotNullParameter(path)\n        return \"map\"\n    }\n}\n\nfun main() {\n    println(Graph.INSTANCE.getMapWithPath(\"path\"))\n}"}
{"kt_path": "charlesfranciscodev__codingame__3ec8060/puzzles/kotlin/src/surface/surface.kt", "Qwen2.5-Coder-1.5B-Instruct": "class Grid(val index: Int) {\n    fun readGameInput() {\n        println(\"Reading game input...\")\n    }\n\n    fun test() {\n        println(\"Testing grid...\")\n    }\n}\n\nfun main(args: Array<String>) {\n    val land = 'L'\n    val water = 'W'\n    val defaultIndex = 0\n\n    val grid = Grid(defaultIndex)\n    grid.readGameInput()\n    grid.test()\n}"}
{"kt_path": "andrew-suprun__AoC-2023__dd5f53e/src/main/kotlin/day03_oop/day03_oop.kt", "Qwen2.5-Coder-1.5B-Instruct": "fun main() {\n    Part1().run()\n    Part2().run()\n}"}
{"kt_path": "getnahid__programing-problem-solves-kotlin__589c392/CyclicRotation.kt", "Qwen2.5-Coder-1.5B-Instruct": "fun solution(arr: IntArray, k: Int): IntArray {\n    val n = arr.size\n    val result = IntArray(n)\n    \n    for (i in 0 until n) {\n        val newIndex = (i + k) % n\n        result[newIndex] = arr[i]\n    }\n    \n    return result\n}"}
{"kt_path": "linisme__LeetCodeInKotlin__4382afc/LongestPalindrome.kt", "Qwen2.5-Coder-1.5B-Instruct": "fun main(args: Array<String>) {\n    val solution = LongestPalindromeSolution()\n    println(solution.longestPalindrome(\"abbccbbdl\"))\n}\n\nclass LongestPalindromeSolution {\n    fun longestPalindrome(s: String): String {\n        if (s.isEmpty()) return \"\"\n        \n        var start = 0\n        var end = 0\n        \n        for (i in 0 until s.length) {\n            var left = i\n            var right = i\n            \n            while (right < s.length && s[right] == s[left]) {\n                right++\n            }\n            \n            left--\n            \n            while (left >= 0 && right < s.length && s[left] == s[right]) {\n                left--\n                right++\n            }\n            \n            val length = right - left - 1\n            \n            if (length > end - start) {\n                start = left + 1\n                end = right\n            }\n        }\n        \n        return s.substring(start, end)\n    }\n}"}
{"kt_path": "iafsilva__codility-lessons__5d86aef/src/main/kotlin/lesson2/OddOccurrencesInArray.kt", "Qwen2.5-Coder-1.5B-Instruct": "class OddOccurrencesInArray {\n    fun solution(arr: IntArray): Int {\n        var count = 0\n        var result = 0\n        for (i in arr) {\n            count = arr.count { it == i }\n            if (count % 2 != 0) {\n                result = i\n                break\n            }\n        }\n        return result\n    }\n\n    fun main() {\n        val arr = intArrayOf(2, 3, 5, 4, 5)\n        println(solution(arr)) // Output: 4\n    }\n}"}
{"kt_path": "jjeda__playground__5d1ee6c/src/oop/algorithm/ProgressionNextNumber.kt", "Qwen2.5-Coder-1.5B-Instruct": "class ProgressionNextNumber {\n    fun solution(numbers: IntArray): Int {\n        val list = numbers.toList()\n        val helper = ProgressionHelper(list)\n        return helper.nextInt()\n    }\n}\n\nclass ProgressionHelper(private val list: List<Int>) {\n    fun nextInt(): Int {\n        if (list.isEmpty()) throw IllegalArgumentException(\"List is empty\")\n        return list.removeAt(0) + 1\n    }\n}"}
{"kt_path": "linisme__LeetCodeInKotlin__4382afc/LengthOfLongestSubstring.kt", "Qwen2.5-Coder-1.5B-Instruct": "fun main(args: Array<String>) {\n    val solution = LengthOfLongestSubstringSolution2()\n    println(solution.lengthOfLongestSubstring(\"abba\"))\n}\n\nclass LengthOfLongestSubstringSolution2 {\n    fun lengthOfLongestSubstring(s: String): Int {\n        if (s == null) throw IllegalArgumentException(\"String cannot be null\")\n        var maxLength = 0\n        var left = 0\n\n        for (right in s.indices) {\n            while (s[right] in s[left..right - 1]) {\n                left++\n            }\n            maxLength = maxOf(maxLength, right - left + 1)\n        }\n\n        return maxLength\n    }\n}"}
{"kt_path": "nschulzke__mancala-puzzle-solver__b130d3b/src/main/kotlin/Main.kt", "Qwen2.5-Coder-1.5B-Instruct": "package com.nschulzke\n\nimport kotlin.collections.SetsKt.setOf\n\nobject MainKt {\n    private val mancalaIndices: Set<Int> = setOf(6, 13)\n\n    fun main() {\n        println(mancalaIndices)\n    }\n}"}
{"kt_path": "sysion__DataStructureAlgorithmKt__6f9afda/TwoSumLessThanTarget.kt", "Qwen2.5-Coder-1.5B-Instruct": "fun main() {\n    val array = arrayOf(10, 20, 30)\n    println(SumTwoNumbersLessThanTarget(array, 15))\n}\n\nfun SumTwoNumbersLessThanTarget(arr: IntArray, target: Int): Int {\n    var left = 0\n    var right = arr.size - 1\n    while (left < right) {\n        val sum = arr[left] + arr[right]\n        if (sum < target) {\n            left++\n        } else {\n            right--\n        }\n    }\n    return left\n}"}
{"kt_path": "linisme__LeetCodeInKotlin__4382afc/FineMedianSortedArrays.kt", "Qwen2.5-Coder-1.5B-Instruct": "fun main(args: Array<String>) {\n    val solution = FindMedianSortedArraysSolution()\n    val result = solution.findMedianSortedArrays(intArrayOf(1, 3, 5), intArrayOf(2, 4, 6))\n    println(result)\n}\n\nclass FindMedianSortedArraysSolution {\n    fun findMedianSortedArrays(nums1: IntArray, nums2: IntArray): Double {\n        val mergedArray = (nums1 + nums2).sorted()\n        if (mergedArray.size % 2 == 0) {\n            return (mergedArray[mergedArray.size / 2 - 1] + mergedArray[mergedArray.size / 2]) / 2.0\n        } else {\n            return mergedArray[mergedArray.size / 2].toDouble()\n        }\n    }\n}"}
{"kt_path": "n81ur3__kotlin-coding-challenges__fdc5941/src/main/kotlin/adventofcode2018/Day18SettlersOfTheNorthPole.kt", "Qwen2.5-Coder-1.5B-Instruct": "fun Day18SettlersOfTheNorthPole.hash(elements: List<List<AreaElement>>) = elements.map { it.toList() }.deepHashCode()"}
{"kt_path": "iafsilva__codility-lessons__5d86aef/src/main/kotlin/lesson3/PermMissingElem.kt", "Qwen2.5-Coder-1.5B-Instruct": "fun main() {\n    val permMissingElem = PermMissingElem()\n    println(permMissingElem.solution(arrayOf(1, 2, 3)))\n}\n\nclass PermMissingElem {\n    fun solution(arr: IntArray): Int {\n        if (arr.isEmpty()) return 1\n\n        arr.sort()\n\n        var left = 0\n        var right = arr.size - 1\n\n        while (left <= right) {\n            val mid = left + (right - left) / 2\n\n            if (arr[mid] == mid + 1) {\n                left = mid + 1\n            } else {\n                right = mid - 1\n            }\n        }\n\n        return left\n    }\n}"}
{"kt_path": "getnahid__programing-problem-solves-kotlin__589c392/OddOccurrencesInArray.kt", "Qwen2.5-Coder-1.5B-Instruct": "fun oddOccurrencesInArray(arr: IntArray): Int {\n    arr.sort()\n    var count = 0\n    var prevValue = arr[0]\n    for (i in 1 until arr.size) {\n        if (arr[i] == prevValue) {\n            count++\n        } else {\n            if (count % 2 != 0) {\n                return prevValue\n            }\n            count = 1\n        }\n        prevValue = arr[i]\n    }\n    if (count % 2 != 0) {\n        return prevValue\n    }\n    return -1\n}"}
{"kt_path": "rupeshsasne__coursera-algorithms-part1__341634c/classroom/src/main/kotlin/com/radix2/algorithms/week3/SortingLinkedList.kt", "Qwen2.5-Coder-1.5B-Instruct": "fun main(args: Array<String>) {\n    val list = LinkedList()\n    for (i in 0..10) {\n        list.add(Integer.valueOf(i))\n    }\n    list.reverseRecursive()\n    println(list)\n}\n\nclass LinkedList<T : Comparable<T>> {\n    private var head: Node? = null\n\n    fun add(value: T) {\n        val newNode = Node(value)\n        newNode.next = head\n        head = newNode\n    }\n\n    fun reverseRecursive(): Unit {\n        if (head == null || head.next == null) {\n            return\n        }\n        val nextNode = head.next\n        head.next = null\n        reverseRecursive()\n        nextNode?.next = head\n    }\n\n    inner class Node(val value: T, var next: Node? = null)\n}"}
{"kt_path": "boris920308__HoOne__8881468/hoon/HoonAlgorithm/src/main/kotlin/boj/week02/recursive_function/FibonacciSequence5.kt", "Qwen2.5-Coder-1.5B-Instruct": "fun main() {\n    val scanner = Scanner(System.in)\n    val n = scanner.nextInt()\n    println(fibonacci(n))\n}\n\nfun fibonacci(n: Int): Int {\n    if (n == 1 || n == 2) return 1\n    return fibonacci(n - 1) + fibonacci(n - 2)\n}"}
{"kt_path": "Codextor__kotlin-codes__68b75a7/src/main/kotlin/PerfectSquares.kt", "Qwen2.5-Coder-1.5B-Instruct": "fun numSquares(n: Int): Int {\n    var count = 0\n    for (i in 1..n) {\n        val square = i * i\n        if (square <= n) {\n            count++\n        }\n    }\n    return count\n}"}
{"kt_path": "Laomedeia__Java8InAction__0dcd843/src/main/java/leetcode/a167_twoSumInputSortArray_SIMPLE/Solution.kt", "Qwen2.5-Coder-1.5B-Instruct": "class Solution {\n    fun twoSum(numbers: IntArray, target: Int): IntArray {\n        val sortedNumbers = numbers.sorted()\n        var left = 0\n        var right = sortedNumbers.size - 1\n\n        while (left < right) {\n            val sum = sortedNumbers[left] + sortedNumbers[right]\n            when {\n                sum == target -> return intArrayOf(left, right)\n                sum < target -> left++\n                sum > target -> right--\n            }\n        }\n\n        return intArrayOf(0, 0) // This line will never be reached as the loop exits when a valid pair is found\n    }\n}"}
{"kt_path": "ariannysOronoz__tutorialKotlin__a779f54/CombinacionesPalabras/src/main/java/Main.kt", "Qwen2.5-Coder-1.5B-Instruct": "fun main(args: Array<String>) {\n    val permutation = Permutation()\n    val caracol = \"CARACOL\"\n    val length = caracol.length\n    permutation.findPermutation(caracol, 0, length)\n    println(\"caracol\")\n}\n\nclass Permutation {\n    fun findPermutation(s: String, start: Int, end: Int) {\n        if (start == end) {\n            println(s)\n            return\n        }\n        for (i in start until end) {\n            s.swap(start, i)\n            findPermutation(s, start + 1, end)\n            s.swap(start, i)\n        }\n    }\n\n    private fun String.swap(i: Int, j: Int) {\n        val temp = this[i]\n        this[i] = this[j]\n        this[j] = temp\n    }\n}"}
{"kt_path": "scientificCommunity__blog-sample__36e291c/algorithms/src/main/kotlin/org/baichuan/sample/algorithms/leetcode/middle/MaxArea.kt", "Qwen2.5-Coder-1.5B-Instruct": "fun main() {\n    val heights = arrayOf(1, 8, 6, 2, 5, 4, 8, 3, 7)\n    println(maxArea(heights))\n}\n\nfun maxArea(heights: IntArray): Int {\n    var left = 0\n    var right = heights.size - 1\n    var maxArea = 0\n\n    while (left < right) {\n        val width = right - left\n        val height = Math.min(heights[left], heights[right])\n        maxArea = Math.max(maxArea, width * height)\n\n        if (heights[left] <= heights[right]) {\n            left++\n        } else {\n            right--\n        }\n    }\n\n    return maxArea\n}"}
{"kt_path": "boris920308__HoOne__8881468/hoon/HoonAlgorithm/src/main/kotlin/programmers/lv01/Lv1_70128.kt", "Qwen2.5-Coder-1.5B-Instruct": "fun main(args: Array<String>) {\n    val result = solution(intArrayOf(4), intArrayOf(-3, -1, 0, 2, 3))\n    println(result)\n}\n\nprivate fun solution(arr1: IntArray, arr2: IntArray): Int {\n    var sum = 0\n    for (i in 0 until arr1.size) {\n        sum += arr1[i] * arr2[i]\n    }\n    return sum\n}"}
{"kt_path": "kotler-dev__kotlin-leetcode__0659e72/src/main/kotlin/exercise/easy/id121/Solution121.kt", "Qwen2.5-Coder-1.5B-Instruct": "fun Solution121.maxProfit(prices: IntArray): Int {\n    if (prices.isEmpty()) return 0\n\n    var minPrice = Int.MAX_VALUE\n    var maxProfit = 0\n\n    for (price in prices) {\n        if (price < minPrice) {\n            minPrice = price\n        } else if (price - minPrice > maxProfit) {\n            maxProfit = price - minPrice\n        }\n    }\n\n    return maxProfit\n}"}
{"kt_path": "marc-bouvier-katas__Kotlin_EduTools_Advent_of_Code_2021__12cf74c/Day 5/Part 1/src/Task.kt", "Qwen2.5-Coder-1.5B-Instruct": "fun overlaps(lines: Array<String>): Int {\n    val linesMap = mapOf()\n    val lineCompanion = Line.Companion\n    val lineOfVentCompanion = LineOfVent.Companion\n\n    for (line in lines) {\n        val lineOfVent = lineOfVentCompanion.fromString(line)\n        val line = lineCompanion.fromLineOfVent(lineOfVent)\n        linesMap[line] = line\n    }\n\n    return linesMap.values.sum { it.overlaps() }\n}"}
{"kt_path": "Laomedeia__Java8InAction__0dcd843/src/main/java/leetcode/a392_isSubSequence_HARD/Solution.kt", "Qwen2.5-Coder-1.5B-Instruct": "class Solution {\n    fun isSubsequence(s: String, t: String): Boolean {\n        var i = 0\n        var j = 0\n        while (i < s.length && j < t.length) {\n            if (s[i] == t[j]) {\n                i++\n            }\n            j++\n        }\n        return i == s.length\n    }\n}"}
{"kt_path": "nickperov__Algorithms__6696f5d/fibonacci/src/main/kotlin/com/nickperov/stud/algorithms/fibonacci/FibonacciLargeGenerator.kt", "Qwen2.5-Coder-1.5B-Instruct": "fun main() {\n    println(\"Hello, large Fibonacci numbers\")\n    val generator = FibonacciLargeTailRecursiveOptimisedGenerator(1000000)\n    println(generator.calculate())\n}"}
{"kt_path": "TonnyL__Windary__39f85cd/Kotlin/src/UniqueBinarySearchTrees.kt", "Qwen2.5-Coder-1.5B-Instruct": "class UniqueBinarySearchTrees {\n    fun numTrees(n: Int): Int {\n        if (n == 0) return 1\n        var dp = IntArray(n + 1)\n        dp[0] = 1\n        dp[1] = 1\n        for (i in 2 until n + 1) {\n            for (j in 0 until i) {\n                dp[i] += dp[j] * dp[i - j - 1]\n            }\n        }\n        return dp[n]\n    }\n\n    companion object {\n        @JvmStatic\n        fun main(args: Array<String>) {\n            val uniqueBSTs = UniqueBinarySearchTrees()\n            println(uniqueBSTs.numTrees(3)) // Output: 5\n        }\n    }\n}"}
{"kt_path": "quincy__euler-kotlin__01d96f6/src/main/kotlin/com/quakbo/euler/Euler4.kt", "Qwen2.5-Coder-1.5B-Instruct": "fun isPalindrome(n: Int): Boolean {\n    val str = n.toString()\n    val reversedStr = str.reversed()\n    return str == reversedStr\n}\n\nfun main(args: Array<String>) {\n    for (i in 999 downTo 100) {\n        for (j in 999 downTo i) {\n            if (isPalindrome(i * j)) {\n                println(\"$i * $j = ${i * j}\")\n                break\n            }\n        }\n    }\n}"}
{"kt_path": "getupminaaa__Algorithm__01187e2/Algorithm/src/main/kotlin/programmers/level1/personalInfoCollectionValidityPeriod.kt", "Qwen2.5-Coder-1.5B-Instruct": "fun main(args: Array<String>) {\n    val solution = Solution()\n    val validPeriods = arrayOf(\n        \"A\", \"B\", \"C\",\n        \"2021.05.02\", \"2021.07.01\", \"2022.02.19\", \"2022.02.20\",\n        \"2022.05.19\"\n    )\n    val result = solution.solution(validPeriods)\n    println(result)\n}\n\nclass Solution {\n    fun solution(validPeriods: Array<String>): Int {\n        // Implement your logic here\n        // For example, you can use a loop to iterate through the array and count occurrences\n        var count = 0\n        for (period in validPeriods) {\n            if (period == \"A\" || period == \"B\" || period == \"C\") {\n                count++\n            }\n        }\n        return count\n    }\n}"}
{"kt_path": "iafsilva__codility-lessons__5d86aef/src/main/kotlin/lesson1/BinaryGap.kt", "Qwen2.5-Coder-1.5B-Instruct": "fun binaryGap(n: Int): Int {\n    var count = 0\n    var maxCount = 0\n    var index = 0\n\n    while (index < n.toString().length) {\n        val char = n.toString()[index]\n        if (char == '1') {\n            count++\n            if (count > maxCount) {\n                maxCount = count\n            }\n        } else {\n            count = 0\n        }\n        index++\n    }\n\n    return maxCount\n}"}
{"kt_path": "zys0909__CodeLabs__869c7c2/src/com/leecode/array/Code1.kt", "Qwen2.5-Coder-1.5B-Instruct": "fun missingNumber1(nums: IntArray): Int {\n    val numsSize = nums.size\n    var sum = 0\n    var expectedSum = (numsSize * (numsSize + 1)) / 2\n\n    for (num in nums) {\n        sum += num\n    }\n\n    return expectedSum - sum\n}\n\nfun missingNumber2(nums: IntArray): Int {\n    val n = nums.size\n    val expectedSum = n * (n + 1) / 2\n    var actualSum = 0\n\n    for (num in nums) {\n        actualSum += num\n    }\n\n    return expectedSum - actualSum\n}"}
{"kt_path": "ykrytsyn__leetcode-in-kotlin__0acf2a6/src/main/kotlin/leetcode/ArrangingCoins.kt", "Qwen2.5-Coder-1.5B-Instruct": "class ArrangingCoins {\n    fun bruteForce(n: Int): Int {\n        var count = 0\n        for (i in 1..n) {\n            count += i\n            if (count >= n) {\n                return i\n            }\n        }\n        return -1\n    }\n\n    fun binarySearch(n: Int): Int {\n        var left = 0\n        var right = n\n        while (left <= right) {\n            val mid = left + (right - left) / 2\n            val coinsNeeded = mid * (mid + 1) / 2\n            if (coinsNeeded == n) {\n                return mid\n            } else if (coinsNeeded < n) {\n                left = mid + 1\n            } else {\n                right = mid - 1\n            }\n        }\n        return -1\n    }\n}"}
{"kt_path": "mayabot__mynlp__b980da3/mynlp/src/main/java/com/mayabot/nlp/module/nwd/ValueObjects.kt", "Qwen2.5-Coder-1.5B-Instruct": "fun addTo(map: HashMap<Character, IntCount>, key: Char, value: Int) {\n    map[key] = map[key]?.let { it + value } ?: IntCount(value)\n}"}
{"kt_path": "jjrodcast__CompetitiveProblems__a91868c/leetcode/UniquePathsTwo.kt", "Qwen2.5-Coder-1.5B-Instruct": "fun main(args: Array<String>) {\n    val solution = Solution()\n    val result = solution.uniquePathsWithObstacles(arrayOf(0, 0, 0))\n    println(result)\n}\n\nclass Solution {\n    fun uniquePathsWithObstacles(obstacleGrid: IntArray): Int {\n        if (obstacleGrid[0][0] == 1 || obstacleGrid[obstacleGrid.size - 1][obstacleGrid.size - 1] == 1) {\n            return 0\n        }\n\n        val rows = obstacleGrid.size\n        val cols = obstacleGrid[0].size\n        val dp = Array(rows) { IntArray(cols) }\n        dp[0][0] = 1\n\n        for (i in 1 until rows) {\n            if (obstacleGrid[i][0] == 1) {\n                break\n            }\n            dp[i][0] = 1\n        }\n\n        for (j in 1 until cols) {\n            if (obstacleGrid[0][j] == 1) {\n                break\n            }\n            dp[0][j] = 1\n        }\n\n        for (i in 1 until rows) {\n            for (j in 1 until cols) {\n                if (obstacleGrid[i][j] == 1) {\n                    continue\n                }\n                dp[i][j] = dp[i-1][j] + dp[i][j-1]\n            }\n        }\n\n        return dp[rows-1][cols-1]\n    }\n}"}
{"kt_path": "boris920308__HoOne__8881468/hoon/HoonAlgorithm/src/main/kotlin/programmers/lv01/Lv1_77884.kt", "Qwen2.5-Coder-1.5B-Instruct": "fun main(args: Array<String>) {\n    println(solution(13, 17))\n}\n\nprivate fun solution(a: Int, b: Int): Int {\n    return countDivisors(b)\n}\n\nprivate fun countDivisors(n: Int): Int {\n    var count = 0\n    for (i in 1..n) {\n        if (n % i == 0) {\n            count++\n        }\n    }\n    return count\n}"}
{"kt_path": "Codextor__kotlin-codes__68b75a7/src/main/kotlin/PartitionArrayForMaximumSum.kt", "Qwen2.5-Coder-1.5B-Instruct": "fun maxSumAfterPartitioning(arr: IntArray, k: Int): Int {\n    val n = arr.size\n    val dp = Array(n + 1) { Int.MAX_VALUE }\n\n    for (i in 1..n) {\n        var currentMax = arr[i - 1]\n        var maxSum = arr[i - 1]\n\n        for (j in i until Math.min(i + k, n)) {\n            currentMax = Math.max(currentMax, arr[j])\n            maxSum = Math.max(maxSum, currentMax * (j - i + 1) + dp[j + 1])\n        }\n\n        dp[i] = maxSum\n    }\n\n    return dp[n]\n}"}
{"kt_path": "scientificCommunity__blog-sample__36e291c/algorithms/src/main/kotlin/org/baichuan/sample/algorithms/leetcode/simple/interview/MajorityElement.kt", "Qwen2.5-Coder-1.5B-Instruct": "class MajorityElement {\n    fun majorityElement(nums: IntArray): Int {\n        var count = 0\n        var candidate = nums[0]\n\n        for (num in nums) {\n            if (candidate == num) {\n                count++\n            } else {\n                count--\n                if (count < 0) {\n                    candidate = num\n                    count = 1\n                }\n            }\n        }\n\n        return candidate\n    }\n}"}
{"kt_path": "rhavran__ProjectEuler__1115674/src/Utils.kt", "Qwen2.5-Coder-1.5B-Instruct": "class UtilsKt {\n    companion object {\n        val INSTANCE = PrimeFactorization()\n\n        fun dividers(n: Long): Long {\n            val primeFactors = INSTANCE.primeFactors(n)\n            var result = 1L\n            for (entry in primeFactors.entrySet()) {\n                val value = entry.value as Number\n                result *= value.toLong()\n            }\n            return result\n        }\n\n        fun sequenceSumStartingFrom(start: Long, end: Long): Long {\n            return sumFromTo(start, end - 1)\n        }\n\n        private fun sumFromTo(start: Long, end: Long): Long {\n            var sum = 0L\n            for (i in start..end) {\n                sum += i\n            }\n            return sum\n        }\n    }\n}\n\nclass PrimeFactorization {\n    fun primeFactors(n: Long): Map<Long, Number> {\n        val factors = mutableMapOf<Long, Number>()\n        var number = n\n        for (i in 2 until Math.sqrt(number).toInt() + 1) {\n            while (number % i == 0) {\n                factors[i] = factors.getOrDefault(i, 0L) + 1\n                number /= i\n            }\n        }\n        if (number > 1) {\n            factors[number] = factors.getOrDefault(number, 0L) + 1\n        }\n        return factors\n    }\n}"}
{"kt_path": "jimmymorales__project-euler__e881cad/src/main/kotlin/Problem4.kt", "Qwen2.5-Coder-1.5B-Instruct": "fun main(args: Array<String>) {\n    println(largestPalindrome())\n}\n\nfun largestPalindrome(): Int {\n    var max = 0\n    for (i in 999 downTo 100) {\n        for (j in i downTo 100) {\n            val palindrome = reverse(i * j)\n            if (palindrome > max && isPalindrome(palindrome)) {\n                max = palindrome\n            }\n        }\n    }\n    return max\n}\n\nfun reverse(n: Int): Int {\n    var reversed = 0\n    while (n != 0) {\n        reversed = reversed * 10 + n % 10\n        n /= 10\n    }\n    return reversed\n}\n\nfun isPalindrome(n: Int): Boolean {\n    return n == reverse(n)\n}"}
{"kt_path": "Codextor__kotlin-codes__68b75a7/src/main/kotlin/PalindromicSubstrings.kt", "Qwen2.5-Coder-1.5B-Instruct": "fun countSubstrings(s: String): Int {\n    var result = 0\n    for (i in 0 until s.length) {\n        result += countSubstringsWithCenter(s, i, i)\n        result += countSubstringsWithCenter(s, i, i + 1)\n    }\n    return result\n}\n\nprivate fun countSubstringsWithCenter(s: String, left: Int, right: Int): Int {\n    var count = 0\n    while (left >= 0 && right < s.length && s[left] == s[right]) {\n        count++\n        left--\n        right++\n    }\n    return count\n}"}
{"kt_path": "antop-dev__algorithm__9a3e762/src/main/kotlin/kr/co/programmers/P12952.kt", "Qwen2.5-Coder-1.5B-Instruct": "class P12952 {\n    fun solution(n: Int): Int {\n        return dfs(n, intArrayOf())\n    }\n\n    private fun dfs(arr: IntArray, visited: IntArray): Int {\n        if (visited.size == arr.size) {\n            return 1\n        }\n        var count = 0\n        for (i in 0 until arr.size) {\n            if (!visited.contains(i)) {\n                visited.add(i)\n                val isValid = valid(arr, i)\n                if (isValid) {\n                    count += dfs(arr, visited)\n                }\n                visited.removeAt(visited.size - 1)\n            }\n        }\n        return count\n    }\n\n    private fun valid(arr: IntArray, index: Int): Boolean {\n        val n = arr[index]\n        for (i in 0 until arr.size) {\n            if (i != index && Math.abs(arr[i] - n) <= 1) {\n                return false\n            }\n        }\n        return true\n    }\n}"}
{"kt_path": "ILIYANGERMANOV__algorithms__4abe4b5/Algorithms/src/main/kotlin/MaxSubArray.kt", "Qwen2.5-Coder-1.5B-Instruct": "fun maxSubArray(nums: IntArray): Int {\n    if (nums == null || nums.isEmpty()) return 0\n\n    var maxSum = nums[0]\n    var currentSum = nums[0]\n\n    for (i in 1 until nums.size) {\n        currentSum = Math.max(nums[i], currentSum + nums[i])\n        maxSum = Math.max(maxSum, currentSum)\n    }\n\n    return maxSum\n}"}
{"kt_path": "AlBovo__Compiti__56a3131/src/main/kotlin/segtree.kt", "Qwen2.5-Coder-1.5B-Instruct": "fun main() {\n    val arr = arrayOf(7, 2, 4, 2, 2, 3, 4)\n    val tree = SegmentTree(arr)\n    println(tree.getSum(0, 4))\n}\n\nclass SegmentTree(private val arr: IntArray) {\n    private var n = arr.size\n    private var tree = Array(n * 2) { Integer.MIN_VALUE }\n\n    init {\n        buildSegmentTree(0, 0, n - 1)\n    }\n\n    private fun buildSegmentTree(node: Int, start: Int, end: Int) {\n        if (start == end) {\n            tree[node] = arr[start]\n        } else {\n            val mid = (start + end) / 2\n            buildSegmentTree(2 * node + 1, start, mid)\n            buildSegmentTree(2 * node + 2, mid + 1, end)\n            tree[node] = tree[2 * node + 1] + tree[2 * node + 2]\n        }\n    }\n\n    fun getSum(start: Int, end: Int): Int {\n        return getSumUtil(0, 0, n - 1, start, end)\n    }\n\n    private fun getSumUtil(node: Int, left: Int, right: Int, qs: Int, qe: Int): Int {\n        if (qs > right || qe < left) return 0\n        if (qs <= left && qe >= right) return tree[node]\n\n        val mid = (left + right) / 2\n        return getSumUtil(2 * node + 1, left, mid, qs, qe) +\n               getSumUtil(2 * node + 2, mid + 1, right, qs, qe)\n    }\n}"}
{"kt_path": "3mtee__exercism-kotlin__6e3eb88/complex-numbers/src/main/kotlin/ComplexNumbers.kt", "Qwen2.5-Coder-1.5B-Instruct": "import kotlin.math.cos\nimport kotlin.math.pow\nimport kotlin.math.sin\n\nfun exponential(complexNumber: ComplexNumber): ComplexNumber {\n    val real = complexNumber.real\n    val imag = complexNumber.imag\n\n    if (real == 0.0 && imag == 0.0) {\n        return ComplexNumber(1.0, 0.0)\n    }\n\n    val expReal = cos(imag.toDouble()) * pow(real.toDouble(), imag.toDouble())\n    val expImag = sin(imag.toDouble()) * pow(real.toDouble(), imag.toDouble())\n\n    return when {\n        real > 0 -> ComplexNumber(expReal, expImag)\n        real < 0 -> ComplexNumber(-expReal, -expImag)\n        else -> ComplexNumber(expReal, 0.0)\n    }\n}\n\ndata class ComplexNumber(val real: Double, val imag: Double)\n\nfun main() {\n    val complexNumber = ComplexNumber(1.0, 1.0)\n    val result = exponential(complexNumber)\n    println(\"Exponential of $complexNumber is $result\")\n}"}
{"kt_path": "perihanmirkelam__ProjectEuler__a24ac44/src/main/kotlin/P014_LongestCollatzSequence.kt", "Qwen2.5-Coder-1.5B-Instruct": "fun main() {\n    p14()\n}\n\nfun p14() {\n    var longestLength = 0\n    var maxLengthNumber = 0\n\n    for (i in 1..1000000) {\n        val length = collatzLength(i)\n        if (length > longestLength) {\n            longestLength = length\n            maxLengthNumber = i\n        }\n    }\n\n    println(\"The number with the longest Collatz sequence is $maxLengthNumber with a length of $longestLength\")\n}\n\nfun collatzLength(n: Long): Int {\n    var length = 0\n    while (n != 1) {\n        if (n % 2 == 0) {\n            n /= 2\n        } else {\n            n = 3 * n + 1\n        }\n        length++\n    }\n    return length\n}"}
{"kt_path": "iafsilva__codility-lessons__5d86aef/src/main/kotlin/lesson2/CyclicRotation.kt", "Qwen2.5-Coder-1.5B-Instruct": "fun cyclicRotation(arr: IntArray, k: Int): IntArray {\n    val n = arr.size\n    val deque = ArrayDeque<Int>()\n    \n    for (i in 0 until n) {\n        deque.add(arr[i])\n    }\n    \n    for (i in 0 until k) {\n        val lastElement = deque.pollLast()\n        deque.offerFirst(lastElement)\n    }\n    \n    return deque.toIntArray()\n}"}
{"kt_path": "boris920308__HoOne__8881468/hoon/HoonAlgorithm/src/main/kotlin/programmers/lv01/Lv1_12912.kt", "Qwen2.5-Coder-1.5B-Instruct": "fun main(args: Array<String>) {\n    println(solution(3, 5))\n    println(secondSolution(3, 5))\n}\n\nprivate fun solution(a: Int, b: Int): Long {\n    var sum = 0L\n    for (i in a until b + 1) {\n        sum += i.toLong()\n    }\n    return sum\n}\n\nprivate fun secondSolution(a: Int, b: Int): Long {\n    val range = LongRange(a, b)\n    return range.sumOfLong()\n}"}
{"kt_path": "darian-catalin-cucer__divide-and-conquer-algorithms__1cea70d/kt.kt", "Qwen2.5-Coder-1.5B-Instruct": "fun quickSort(arr: IntArray, low: Int, high: Int): Unit {\n    if (low < high) {\n        val pivotIndex = partition(arr, low, high)\n        quickSort(arr, low, pivotIndex - 1)\n        quickSort(arr, pivotIndex + 1, high)\n    }\n}\n\nfun partition(arr: IntArray, low: Int, high: Int): Int {\n    val pivot = arr[high]\n    var i = low - 1\n    for (j in low until high) {\n        if (arr[j] <= pivot) {\n            i++\n            val temp = arr[i]\n            arr[i] = arr[j]\n            arr[j] = temp\n        }\n    }\n    val temp = arr[i + 1]\n    arr[i + 1] = arr[high]\n    arr[high] = temp\n    return i + 1\n}"}
{"kt_path": "TonnyL__Windary__39f85cd/Kotlin/src/ThreeSumClosest.kt", "Qwen2.5-Coder-1.5B-Instruct": "fun threeSumClosest(nums: IntArray, target: Int): Int {\n    nums.sort()\n    var closest = Int.MAX_VALUE\n    val n = nums.size\n\n    for (i in 0 until n - 2) {\n        var left = i + 1\n        var right = n - 1\n\n        while (left < right) {\n            val sum = nums[i] + nums[left] + nums[right]\n            if (sum == target) {\n                return target\n            }\n\n            if (Math.abs(sum - target) < Math.abs(closest - target)) {\n                closest = sum\n            }\n\n            if (sum > target) {\n                right--\n            } else {\n                left++\n            }\n        }\n    }\n\n    return closest\n}"}
{"kt_path": "Javran__leetcode__f3899fe/bulb-switcher/Solution.kt", "Qwen2.5-Coder-1.5B-Instruct": "class Solution {\n\n    companion object Companion {\n        fun main(args: Array<String>) {\n            val solution = Solution()\n            println(solution.bulbSwitch(10))\n        }\n\n        fun bulbSwitch(n: Int): Int {\n            return (Math.floor(Math.sqrt(n.toDouble()))).toInt()\n        }\n    }\n}"}
{"kt_path": "TonnyL__Windary__39f85cd/Kotlin/src/NextPermutation.kt", "Qwen2.5-Coder-1.5B-Instruct": "fun main() {\n    val nums = intArrayOf(3, 2, 1)\n    nextPermutation(nums)\n    println(nums) // Output: [1, 2, 3]\n}\n\nfun nextPermutation(nums: IntArray) {\n    var i = nums.size - 2\n    while (i >= 0 && nums[i] >= nums[i + 1]) {\n        i--\n    }\n    if (i == -1) {\n        nums.reverse()\n        return\n    }\n    var j = nums.size - 1\n    while (nums[j] <= nums[i]) {\n        j--\n    }\n    swap(nums, i, j)\n    nums.sort(i + 1, nums.size)\n}\n\nprivate fun swap(nums: IntArray, i: Int, j: Int) {\n    val temp = nums[i]\n    nums[i] = nums[j]\n    nums[j] = temp\n}\n\nprivate fun reverse(nums: IntArray, start: Int, end: Int) {\n    var left = start\n    var right = end\n    while (left < right) {\n        val temp = nums[left]\n        nums[left] = nums[right]\n        nums[right] = temp\n        left++\n        right--\n    }\n}"}
{"kt_path": "boris920308__HoOne__8881468/hoon/HoonAlgorithm/src/main/kotlin/programmers/lv01/Lv1_12940.kt", "Qwen2.5-Coder-1.5B-Instruct": "fun main(args: Array<String>) {\n    println(solution(3, 12))\n    println(solution(2, 5))\n}\n\nprivate fun solution(a: Int, b: Int): IntArray {\n    val gcd = findGCD(a, b)\n    val lcm = findLCM(a, b)\n    return listOf(gcd, lcm).toIntArray()\n}\n\nprivate fun findGCD(x: Int, y: Int): Int {\n    while (y != 0) {\n        val temp = y\n        y = x % y\n        x = temp\n    }\n    return x\n}\n\nprivate fun findLCM(x: Int, y: Int): Int {\n    return (x * y) / findGCD(x, y)\n}"}
{"kt_path": "JiangKlijna__leetcode-learning__65a1348/kt/001 Two Sum/TwoSum.kt", "Qwen2.5-Coder-1.5B-Instruct": "class TwoSum {\n    fun twoSum(numbers: IntArray, target: Int): IntArray? {\n        val map = HashMap<Int, Int>()\n        for (i in 0 until numbers.size) {\n            val complement = target - numbers[i]\n            if (map.containsKey(complement)) {\n                return intArrayOf(map[complement]!!, i)\n            }\n            map[numbers[i]] = i\n        }\n        return null\n    }\n\n    companion object {\n        @JvmStatic\n        fun main(args: Array<String>) {\n            val twoSum = TwoSum()\n            val result = twoSum.twoSum(intArrayOf(2, 7, 11, 15), 9)\n            println(result?.joinToString(\", \")) // Output: 0, 1\n        }\n    }\n}"}
{"kt_path": "rupeshsasne__coursera-algorithms-part1__341634c/classroom/src/main/kotlin/com/radix2/algorithms/week1/UnionFind.kt", "Qwen2.5-Coder-1.5B-Instruct": "fun main(args: Array<String>) {\n    val uf = WeightedQuickUnionWithPathCompressionUF(10)\n    uf.union(4, 3)\n    uf.union(3, 8)\n    uf.union(5, 6)\n    uf.union(5, 7)\n    uf.union(4, 9)\n    uf.union(2, 1)\n    uf.union(5, 0)\n    uf.union(7, 2)\n    uf.union(8, 6)\n    uf.union(9, 4)\n}"}
{"kt_path": "boris920308__HoOne__8881468/hoon/HoonAlgorithm/src/main/kotlin/programmers/lv01/Lv1_68935.kt", "Qwen2.5-Coder-1.5B-Instruct": "fun main(args: Array<String>) {\n    println(solution(45))\n}\n\nprivate fun solution(n: Int): Int {\n    val radix = checkRadix(n)\n    val str = Integer.toString(n, radix)\n    val reversedStr = str.reversed()\n    val num = Integer.parseInt(reversedStr, radix)\n    return num\n}\n\nprivate fun checkRadix(n: Int): Int {\n    return when (n) {\n        in 2..36 -> n\n        else -> throw IllegalArgumentException(\"Invalid radix\")\n    }\n}"}
{"kt_path": "korilin__DSA-kt__b96ba1b/src/main/kotlin/sort_algorithm/quickSort.kt", "Qwen2.5-Coder-1.5B-Instruct": "fun quickSort(arr: IntArray): Unit {\n    quickSortInner(arr, 0, arr.size - 1)\n}\n\nprivate fun quickSortInner(arr: IntArray, left: Int, right: Int): Unit {\n    if (left >= right) return\n\n    val pivotIndex = quickSortPartition(arr, left, right)\n    quickSortInner(arr, left, pivotIndex - 1)\n    quickSortInner(arr, pivotIndex + 1, right)\n}\n\nprivate fun quickSortPartition(arr: IntArray, low: Int, high: Int): Int {\n    val pivot = arr[high]\n    var i = low - 1\n\n    for (j in low until high) {\n        if (arr[j] < pivot) {\n            i++\n            swap(arr, i, j)\n        }\n    }\n\n    swap(arr, i + 1, high)\n    return i + 1\n}\n\nprivate fun swap(arr: IntArray, index1: Int, index2: Int) {\n    val temp = arr[index1]\n    arr[index1] = arr[index2]\n    arr[index2] = temp\n}"}
{"kt_path": "gardnerdickson__advent-of-code-2015__4a23ab3/src/day_10.kt", "Qwen2.5-Coder-1.5B-Instruct": "fun main(args: Array<String>) {\n    val day10 = Day10.INSTANCE\n    val part1 = day10.part1(\"1113222113\")\n    println(\"Part 1: $part1\")\n\n    val part2 = day10.part2(\"1113222113\")\n    println(\"Part 2: $part2\")\n}\n\nclass Day10 {\n    companion object {\n        val INSTANCE = Day10()\n    }\n\n    fun part1(input: String): Int {\n        // Implementation of part1 logic\n        return input.length\n    }\n\n    fun part2(input: String): Int {\n        // Implementation of part2 logic\n        return input.length\n    }\n}"}
{"kt_path": "gardnerdickson__advent-of-code-2015__4a23ab3/src/day_2.kt", "Qwen2.5-Coder-1.5B-Instruct": "class Day2 {\n    companion object {\n        val INSTANCE = Day2()\n\n        fun part1(input: String): Int {\n            // Implementation of part1 logic\n            return input.length\n        }\n\n        fun part2(input: String): Int {\n            // Implementation of part2 logic\n            return input.count { it == 'a' }\n        }\n    }\n\n    @JvmStatic\n    fun main(args: Array<String>) {\n        val input = args[0]\n        println(\"Part 1: ${DAY2.INSTANCE.part1(input)}\")\n        println(\"Part 2: ${DAY2.INSTANCE.part2(input)}\")\n    }\n}"}
{"kt_path": "gardnerdickson__advent-of-code-2015__4a23ab3/src/day_3.kt", "Qwen2.5-Coder-1.5B-Instruct": "fun main(args: Array<String>) {\n    val day3 = Day3.INSTANCE\n    val inputPath = \"res/day_3_input.txt\"\n\n    val part1Result = day3.part1(inputPath)\n    println(\"Part 1: $part1Result\")\n\n    val part2Result = day3.part2(inputPath)\n    println(\"Part 2: $part2Result\")\n}\n\nobject Day3 {\n    private var INSTANCE: Day3? = null\n\n    fun getInstance(): Day3 {\n        if (INSTANCE == null) {\n            INSTANCE = Day3()\n        }\n        return INSTANCE!!\n    }\n\n    fun part1(inputPath: String): Int {\n        // Implementation of part1 logic here\n        return 0 // Placeholder return value\n    }\n\n    fun part2(inputPath: String): Int {\n        // Implementation of part2 logic here\n        return 0 // Placeholder return value\n    }\n}"}
{"kt_path": "antop-dev__algorithm__9a3e762/src/main/kotlin/kr/co/programmers/P161988.kt", "Qwen2.5-Coder-1.5B-Instruct": "fun P161988.solution(numbers: IntArray): Long {\n    val length = numbers.size\n    val maxPositive = max(numbers, 0)\n    val maxNegative = max(numbers, -1)\n    return Math.max(maxPositive, maxNegative)\n}\n\nprivate fun P161988.max(numbers: IntArray, target: Int): Long {\n    var maxLength = 0\n    var currentLength = 0\n    for (i in numbers.indices) {\n        if (numbers[i] == target) {\n            currentLength++\n            maxLength = Math.max(currentLength, maxLength)\n        } else {\n            currentLength = 0\n        }\n    }\n    return maxLength.toLong()\n}"}
{"kt_path": "alexjlockwood__bees-and-bombs-compose__0d7a86b/app/src/main/java/com/alexjlockwood/beesandbombs/demos/utils/MathUtils.kt", "Qwen2.5-Coder-1.5B-Instruct": "package com.alexjlockwood.beesandbombs.demos.utils\n\nobject MathUtils {\n\n    val PI = 3.14159265358979323846\n    val TWO_PI = 2 * PI\n    val HALF_PI = PI / 2\n\n    fun dist(x1: Float, y1: Float, x2: Float, y2: Float): Float {\n        return kotlin.math.sqrt((x2 - x1).pow(2) + (y2 - y1).pow(2))\n    }\n\n    fun lerp(start: Float, end: Float, t: Float): Float {\n        return start + (end - start) * t\n    }\n\n    fun map(value: Float, inputMin: Float, inputMax: Float, outputMin: Float, outputMax: Float): Float {\n        return (value - inputMin) * (outputMax - outputMin) / (inputMax - inputMin) + outputMin\n    }\n\n    fun toDegrees(radians: Float): Float {\n        return radians * 180 / Math.PI\n    }\n\n    fun ease(t: Float): Float {\n        return when (t) {\n            in 0..0.5 -> 2 * t * t\n            else -> 1 - 2 * (t - 0.5) * (t - 0.5)\n        }\n    }\n\n    fun ease(fromValue: Float, toValue: Float): Float {\n        val t = fromValue / (fromValue + toValue)\n        return ease(t)\n    }\n}"}
{"kt_path": "chengw315__daily-study__501b881/letcode/src/main/java/daily/LeetCodeLCP13.kt", "Qwen2.5-Coder-1.5B-Instruct": "fun main(args: Array<String>) {\n    val solution = SolutionLCP13()\n    println(solution.minimalSteps(arrayOf(\"S#O\", \"M.\", \"M.T\")))\n    println(solution.minimalSteps(arrayOf(\"S#O\", \"#M\", \"M.T\")))\n}\n\nclass SolutionLCP13 {\n    fun minimalSteps(strings: Array<String>): Int {\n        return strings.map { it.length }.sum()\n    }\n}"}
{"kt_path": "rajatenzyme__Coding-Journey__65a0570/Algo_Ds_Notes-master/Algo_Ds_Notes-master/Floyd_Warshall_Algorithm/Floyd_Warshall_Algorithm.kt", "Qwen2.5-Coder-1.5B-Instruct": "import java.util.Arrays\n\nclass FloydWarshall {\n    companion object {\n        val INSTANCE = this\n    }\n\n    fun doCalcs(matrix: Array<IntArray>): Unit {\n        for (i in matrix.indices) {\n            for (j in matrix.indices) {\n                if (i == j) continue\n                for (k in matrix.indices) {\n                    matrix[i][j] = minOf(matrix[i][j], matrix[i][k] + matrix[k][j])\n                }\n            }\n        }\n    }\n}\n\nfun main(args: Array<String>) {\n    val matrix = arrayOf(\n        intArrayOf(0, 3, 1),\n        intArrayOf(3, 0, 2),\n        intArrayOf(1, 2, 0)\n    )\n\n    FloydWarshall.INSTANCE.doCalcs(matrix)\n\n    println(Arrays.deepToString(matrix))\n}"}
{"kt_path": "brunorene__advent_of_code_2018__0cb6814/src/main/kotlin/advent/of/code/day17/Solution.kt", "Qwen2.5-Coder-1.5B-Instruct": "import java.io.File\nimport kotlin.text.Regex\n\nclass SolutionKt {\n    companion object {\n        private val input: File = File(\"day17.txt\")\n        private val multipleCoord: Regex = Regex(\"(x|y)=([.0-9]+)\\\\.(\\\\.0-9]+)\")\n        private val oneCoord: Regex = Regex(\"(x|y)=([.0-9]+)\")\n\n        fun part1(): Int {\n            val underground = Underground(input)\n            val clay = underground.getClay()\n            println(clay.size)\n            return 1\n        }\n\n        fun part2(): Int {\n            return 2\n        }\n    }\n\n    data class Underground(val file: File) {\n        fun getClay(): Set<String> {\n            val lines = file.readLines().map { it.split(\",\") }\n            val claySet = mutableSetOf<String>()\n\n            for (line in lines) {\n                val parts = line.split(\"=\")\n                val coord = parts[1].split(\"..\").map { it.toDouble() }\n                val xStart = coord[0].toInt()\n                val xEnd = coord[1].toInt()\n                val yStart = coord[2].toInt()\n                val yEnd = coord[3].toInt()\n\n                if (parts[0] == \"x\") {\n                    for (y in yStart..yEnd) {\n                        claySet.add(\"$xStart,$y\")\n                    }\n                } else {\n                    for (x in xStart..xEnd) {\n                        claySet.add(\"$x,$yStart\")\n                    }\n                }\n            }\n\n            return claySet\n        }\n    }\n}"}
{"kt_path": "Simplation__OpenSourceRepository__d45feaa/算法/一维数组的动态和1480.kt", "Qwen2.5-Coder-1.5B-Instruct": "fun main(args: Array<String>) {\n    val arr1 = arrayOf(1, 2, 3, 4, 5)\n    val arr2 = arrayOf(1, 2, 3, 4, 5)\n    println(sumArr(arr1, arr2))\n}\n\nfun sumArr(nums1: IntArray, nums2: IntArray): Int {\n    var sum = 0\n    for (i in 0 until nums1.size) {\n        sum += nums1[i] + nums2[i]\n    }\n    return sum\n}"}
{"kt_path": "jimmymorales__project-euler__e881cad/src/main/kotlin/Problem3.kt", "Qwen2.5-Coder-1.5B-Instruct": "fun main(args: Array<String>) {\n    println(solution3(600851475143L))\n}\n\nprivate fun solution3(n: Long): Long {\n    var x = n\n    while (x > 0) {\n        val y = x % 10\n        when (y) {\n            2 -> x /= 2\n            3 -> x /= 3\n            5 -> x /= 5\n            7 -> x /= 7\n        }\n    }\n    return x\n}"}
{"kt_path": "age-series__ElectricalAge2__86d843f/src/main/kotlin/org/eln2/mc/data/SegmentTree.kt", "Qwen2.5-Coder-1.5B-Instruct": "class SegmentTree<T>(\n    private val root: SegmentTreeNode<T>\n) {\n\n    fun queryOrNull(query: Double): T? {\n        return if (!root.contains(query)) null else root.query(query)\n    }\n\n    fun query(query: Double): T {\n        val result = root.query(query)\n        if (result == null) throw IllegalStateException(\"not found\")\n        return result\n    }\n}\n\ndata class SegmentTreeNode<T>(\n    var value: T,\n    var left: SegmentTreeNode<T>? = null,\n    var right: SegmentTreeNode<T>? = null\n)\n\nfun SegmentTreeNode<T>.contains(query: Double): Boolean {\n    return query >= this.value && query <= this.right?.value ?: Double.MAX_VALUE\n}\n\nfun SegmentTreeNode<T>.query(query: Double): T? {\n    if (query < this.value || query > this.right?.value ?: Double.MAX_VALUE) return null\n\n    if (this.left != null && this.left!!.right?.value!! <= query) {\n        return this.left!!.query(query)\n    } else {\n        return this.right?.query(query) ?: this.value\n    }\n}"}
{"kt_path": "ykrytsyn__leetcode-in-kotlin__0acf2a6/src/main/kotlin/leetcode/UniquePaths.kt", "Qwen2.5-Coder-1.5B-Instruct": "class UniquePaths {\n    fun dynamicProgramming(m: Int, n: Int): Int {\n        val dp = Array(m + 1) { IntArray(n + 1) }\n        for (i in 1..m) {\n            for (j in 1..n) {\n                dp[i][j] = dp[i-1][j] + dp[i][j-1]\n            }\n        }\n        return dp[m][n]\n    }\n\n    fun recursive(m: Int, n: Int): Int {\n        if (m == 0 || n == 0) return 0\n        if (m == 1 || n == 1) return 1\n        return recursive(m-1, n) + recursive(m, n-1)\n    }\n}"}
{"kt_path": "quincy__euler-kotlin__01d96f6/src/main/kotlin/com/quakbo/euler/Euler6.kt", "Qwen2.5-Coder-1.5B-Instruct": "fun main(args: Array<String>) {\n    val sequence = generateSequence(1) { it + 1 }\n    val squaresSum = sequence.take(100).map { it * it }.sum()\n    val sumsSquare = sequence.take(100).sum()\n    println(sumsSquare - squaresSum)\n}"}
{"kt_path": "Kirchberg__BigDataPL__b6a459a/LR7/src/main/kotlin/Task1V3.kt", "Qwen2.5-Coder-1.5B-Instruct": "fun main() {\n    task1V3()\n}\n\nclass WordChainFinder(private val words: List<String>) {\n    fun findLongestWordChain(): List<String> {\n        // Implementation of WordChainFinder logic here\n        // For simplicity, let's assume it returns an empty list\n        return listOf()\n    }\n}\n\nfun task1V3() {\n    val words = listOf(\"apple\", \"banana\", \"cherry\")\n    val finder = WordChainFinder(words)\n    val longestChain = finder.findLongestWordChain()\n    println(\"Longest word chain: ${longestChain.joinToString(\", \")}\")\n}"}
{"kt_path": "fredyw__leetcode__a59d77c/src/main/kotlin/leetcode/Problem2064.kt", "Qwen2.5-Coder-1.5B-Instruct": "class Problem2064 {\n    fun minimizedMaximum(capacity: Int, quantities: IntArray): Int {\n        val quantities = quantities.filterNotNull()\n        var minCapacity = 1\n        var maxCapacity = quantities.maxOrNull()?.toInt() ?: 1\n\n        while (minCapacity <= maxCapacity) {\n            val midCapacity = (minCapacity + maxCapacity) / 2\n            if (canDistribute(capacity, quantities, midCapacity)) {\n                maxCapacity = midCapacity - 1\n            } else {\n                minCapacity = midCapacity + 1\n            }\n        }\n\n        return minCapacity\n    }\n\n    private fun canDistribute(capacity: Int, quantities: IntArray, targetCapacity: Int): Boolean {\n        var remainingCapacity = capacity\n        for (quantity in quantities) {\n            remainingCapacity -= quantity % targetCapacity\n        }\n        return remainingCapacity == 0\n    }\n}"}
