{"kt_path": "remisultan__multiarm-bandit-algorithm-kotlin__ead934d/core-bandit/src/main/kotlin/org/rsultan/bandit/algorithms/BanditAlgorithm.kt", "Qwen2.5-Coder-7B-Instruct": "package org.rsultan.bandit.algorithms\n\ninterface BanditAlgorithm {\n    fun selectArm(): Int\n    fun update(index: Int, value: Float)\n}"}
{"kt_path": "n81ur3__kotlin-coding-challenges__fdc5941/src/main/kotlin/adventofcode2018/Day22ModeMaze.kt", "Qwen2.5-Coder-7B-Instruct": "final class Day22ModeMaze {\n    constructor() : super()\n}"}
{"kt_path": "n81ur3__kotlin-coding-challenges__fdc5941/src/main/kotlin/adventofcode2017/Day21FractalArt.kt", "Qwen2.5-Coder-7B-Instruct": "final class Day21FractalArt {\n    constructor()\n}"}
{"kt_path": "n81ur3__kotlin-coding-challenges__fdc5941/src/main/kotlin/adventofcode2017/Day03SpiralMemory.kt", "Qwen2.5-Coder-7B-Instruct": "final class Day03SpiralMemory {\n    constructor()\n}"}
{"kt_path": "n81ur3__kotlin-coding-challenges__fdc5941/src/main/kotlin/adventofcode2019/Day03CrossedWires.kt", "Qwen2.5-Coder-7B-Instruct": "package adventofcode2019\n\nclass Day03CrossedWires()"}
{"kt_path": "n81ur3__kotlin-coding-challenges__fdc5941/src/main/kotlin/adventofcode2018/Day04ReposeRecord.kt", "Qwen2.5-Coder-7B-Instruct": "package adventofcode2018\n\nclass Day04ReposeRecord()"}
{"kt_path": "n81ur3__kotlin-coding-challenges__fdc5941/src/main/kotlin/adventofcode2017/Day08LikeRegisters.kt", "Qwen2.5-Coder-7B-Instruct": "package adventofcode2017\n\nclass Day08LikeRegisters()"}
{"kt_path": "n81ur3__kotlin-coding-challenges__fdc5941/src/main/kotlin/adventofcode2018/Day11ChronalCharge.kt", "Qwen2.5-Coder-7B-Instruct": "package adventofcode2018\n\nclass Day11ChronalCharge()"}
{"kt_path": "n81ur3__kotlin-coding-challenges__fdc5941/src/main/kotlin/adventofcode2020/Day19MonsterMessage.kt", "Qwen2.5-Coder-7B-Instruct": "final class Day19MonsterMessage constructor() {\n}"}
{"kt_path": "n81ur3__kotlin-coding-challenges__fdc5941/src/main/kotlin/adventofcode2017/Day07RecursiveCircus.kt", "Qwen2.5-Coder-7B-Instruct": "package adventofcode2017\n\nclass Day07RecursiveCircus()"}
{"kt_path": "n81ur3__kotlin-coding-challenges__fdc5941/src/main/kotlin/adventofcode2019/Day12TheNbodyProblem.kt", "Qwen2.5-Coder-7B-Instruct": "package adventofcode2019\n\nclass Day12TheNbodyProblem {\n    constructor()\n}"}
{"kt_path": "n81ur3__kotlin-coding-challenges__fdc5941/src/main/kotlin/adventofcode2018/Day15BeverageBandits.kt", "Qwen2.5-Coder-7B-Instruct": "final class Day15BeverageBandits {\n    constructor() : super()\n}"}
{"kt_path": "n81ur3__kotlin-coding-challenges__fdc5941/src/main/kotlin/adventofcode2020/Day07HandyHaversacks.kt", "Qwen2.5-Coder-7B-Instruct": "class Day07HandyHaversacks {\n    constructor()\n}"}
{"kt_path": "n81ur3__kotlin-coding-challenges__fdc5941/src/main/kotlin/adventofcode2018/Day07TheSumOfItsParts.kt", "Qwen2.5-Coder-7B-Instruct": "package adventofcode2018\n\nclass Day07TheSumOfItsParts {\n    constructor()\n}"}
{"kt_path": "n81ur3__kotlin-coding-challenges__fdc5941/src/main/kotlin/adventofcode2017/Day25TheHaltingProblem.kt", "Qwen2.5-Coder-7B-Instruct": "package adventofcode2017\n\nfinal class Day25TheHaltingProblem constructor() {\n}"}
{"kt_path": "n81ur3__kotlin-coding-challenges__fdc5941/src/main/kotlin/adventofcode2019/Day06UniversalOrbitMap.kt", "Qwen2.5-Coder-7B-Instruct": "package adventofcode2019\n\nclass Day06UniversalOrbitMap()"}
{"kt_path": "n81ur3__kotlin-coding-challenges__fdc5941/src/main/kotlin/adventofcode2019/Day10MonitoringStation.kt", "Qwen2.5-Coder-7B-Instruct": "final class Day10MonitoringStation {\n    constructor()\n}"}
{"kt_path": "n81ur3__kotlin-coding-challenges__fdc5941/src/main/kotlin/adventofcode2018/Day06ChronalCoordinates.kt", "Qwen2.5-Coder-7B-Instruct": "final class Day06ChronalCoordinates {\n    constructor()\n}"}
{"kt_path": "n81ur3__kotlin-coding-challenges__fdc5941/src/main/kotlin/adventofcode2020/Day21AllergenAssessment.kt", "Qwen2.5-Coder-7B-Instruct": "final class Day21AllergenAssessment {\n    constructor()\n}"}
{"kt_path": "n81ur3__kotlin-coding-challenges__fdc5941/src/main/kotlin/adventofcode2017/Day24ElectromagneticMoat.kt", "Qwen2.5-Coder-7B-Instruct": "final class Day24ElectromagneticMoat"}
{"kt_path": "n81ur3__kotlin-coding-challenges__fdc5941/src/main/kotlin/adventofcode2018/Day12SubterraneanSustainability.kt", "Qwen2.5-Coder-7B-Instruct": "package adventofcode2018\n\nclass Day12SubterraneanSustainability()"}
{"kt_path": "n81ur3__kotlin-coding-challenges__fdc5941/src/main/kotlin/adventofcode2018/Day23ExperimentalEmergencyTeleportation.kt", "Qwen2.5-Coder-7B-Instruct": "package adventofcode2018\n\nclass Day23ExperimentalEmergencyTeleportation {\n    constructor()\n}"}
{"kt_path": "alebedev__aoc2022__d6ba46b/src/main/kotlin/Map.kt", "Qwen2.5-Coder-7B-Instruct": "object AocMap {\n    fun solve() {\n        // Implementation of solve method\n    }\n}\n\nfun main() {\n    AocMap.solve()\n}\n\nfun main(args: Array<String>) {\n    main()\n}"}
{"kt_path": "andrewrlee__adventOfCode2020__a9c21a6/src/main/kotlin/File09.kt", "Qwen2.5-Coder-7B-Instruct": "fun main(args: Array<String>) {\n    val challenge = Challenge09()\n    challenge.solve()\n}"}
{"kt_path": "andrewrlee__adventOfCode2020__a9c21a6/src/main/kotlin/File08.kt", "Qwen2.5-Coder-7B-Instruct": "fun main(args: Array<String>) {\n    val challenge = Challenge08()\n    challenge.solve()\n}"}
{"kt_path": "andrewrlee__adventOfCode2020__a9c21a6/src/main/kotlin/File02.kt", "Qwen2.5-Coder-7B-Instruct": "fun main(args: Array<String>) {\n    val challenge = Challenge02()\n    challenge.solve()\n}"}
{"kt_path": "andrewrlee__adventOfCode2020__a9c21a6/src/main/kotlin/File07.kt", "Qwen2.5-Coder-7B-Instruct": "fun main(args: Array<String>) {\n    val challenge = Challenge07()\n    challenge.solve()\n}"}
{"kt_path": "charlesfranciscodev__codingame__3ec8060/puzzles/kotlin/src/war/war.kt", "Qwen2.5-Coder-7B-Instruct": "fun main(args: Array<String>) {\n    val game = Game()\n    game.play()\n}"}
{"kt_path": "al-volkov__spbu_2020_kotlin_homeworks__5049681/src/main/kotlin/homework_5/Task1.kt", "Qwen2.5-Coder-7B-Instruct": "package homework_5\n\nimport kotlin.jvm.internal.Intrinsics\nimport kotlin.text.StringsKt\n\nfun isNumber(s: String): Boolean {\n    Intrinsics.checkNotNullParameter(s, \"<this>\")\n    return StringsKt.toIntOrNull(s) != null\n}"}
{"kt_path": "iafsilva__codility-lessons__5d86aef/src/main/kotlin/lesson3/FrogJmp.kt", "Qwen2.5-Coder-7B-Instruct": "class FrogJmp {\n    fun solution(X: Int, Y: Int, D: Int): Int {\n        val distance = Y - X\n        val jumps = distance / D\n        return if (distance % D == 0) jumps else jumps + 1\n    }\n}"}
{"kt_path": "mikhalchenko-alexander__advent-of-kotlin-2018-week1__c483ade/src/main/kotlin/com/anahoret/pathfinding/MarkingWayOnMap.kt", "Qwen2.5-Coder-7B-Instruct": "package com.anahoret.pathfinding\n\nimport kotlin.jvm.internal.Intrinsics\n\nfun addPath(path: String): String {\n    Intrinsics.checkNotNullParameter(path, \"path\")\n    return Graph.INSTANCE.getMapWithPath(path)\n}"}
{"kt_path": "charlesfranciscodev__codingame__3ec8060/puzzles/kotlin/src/surface/surface.kt", "Qwen2.5-Coder-7B-Instruct": "object SurfaceKt {\n    const val LAND: Char = 'L'\n    const val WATER: Char = 'W'\n    const val DEFAULT_INDEX: Int = 0\n\n    @JvmStatic\n    fun main(args: Array<String>) {\n        val grid = Grid()\n        grid.readGameInput()\n        grid.test()\n    }\n}"}
{"kt_path": "andrew-suprun__AoC-2023__dd5f53e/src/main/kotlin/day03_oop/day03_oop.kt", "Qwen2.5-Coder-7B-Instruct": "fun main(args: Array<String>) {\n    val part1 = Part1(\"input.data\")\n    part1.run()\n\n    val part2 = Part2(\"input.data\")\n    part2.run()\n}"}
{"kt_path": "getnahid__programing-problem-solves-kotlin__589c392/CyclicRotation.kt", "Qwen2.5-Coder-7B-Instruct": "fun solution(A: IntArray, K: Int): IntArray {\n    requireNotNull(A) { \"A\" }\n    val n = A.size\n    val result = IntArray(n)\n    var j = 0\n    for (i in A.indices) {\n        result[(i + K) % n] = A[i]\n    }\n    return result\n}"}
{"kt_path": "linisme__LeetCodeInKotlin__4382afc/LongestPalindrome.kt", "Qwen2.5-Coder-7B-Instruct": "fun main(args: Array<String>) {\n    val solution = LongestPalindromeSolution()\n    val result = solution.longestPalindrome(\"abbccbbdl\")\n    println(result)\n}"}
{"kt_path": "iafsilva__codility-lessons__5d86aef/src/main/kotlin/lesson2/OddOccurrencesInArray.kt", "Qwen2.5-Coder-7B-Instruct": "package lesson2\n\nclass OddOccurrencesInArray {\n\n    fun solution(a: Int[]): Int {\n        var result = 0\n        for (i in a) {\n            result = result xor i\n        }\n        return result\n    }\n\n}"}
{"kt_path": "jjeda__playground__5d1ee6c/src/oop/algorithm/ProgressionNextNumber.kt", "Qwen2.5-Coder-7B-Instruct": "package oop.algorithm\n\nclass ProgressionNextNumber {\n    fun solution(numbers: IntArray): Int {\n        checkNotNull(numbers) { \"common\" }\n        val helper = ProgressionHelper(numbers.toList())\n        return helper.nextInt()\n    }\n}\n\nclass ProgressionHelper(private val numbers: List<Int>) {\n    fun nextInt(): Int {\n        // Implementation of nextInt method\n        return 0 // Placeholder for actual implementation\n    }\n}"}
{"kt_path": "linisme__LeetCodeInKotlin__4382afc/LengthOfLongestSubstring.kt", "Qwen2.5-Coder-7B-Instruct": "fun main(args: Array<String>) {\n    val solution = LengthOfLongestSubstringSolution2()\n    val result = solution.lengthOfLongestSubstring(\"abba\")\n    println(result)\n}"}
{"kt_path": "nschulzke__mancala-puzzle-solver__b130d3b/src/main/kotlin/Main.kt", "Qwen2.5-Coder-7B-Instruct": "package com.nschulzke\n\nprivate val mancalaIndices: Set<Int> = setOf(6, 13)\n\nfun access$getMancalaIndices$p(): Set<Int> {\n    return mancalaIndices\n}"}
{"kt_path": "sysion__DataStructureAlgorithmKt__6f9afda/TwoSumLessThanTarget.kt", "Qwen2.5-Coder-7B-Instruct": "fun main() {\n    val array = intArrayOf(10, 20, 30)\n    val target = 15\n    SumTwoNumbersLessThanTarget(array, target)\n}\n\nfun SumTwoNumbersLessThanTarget(intArray: IntArray, target: Int): Int {\n    checkNotNull(intArray) { \"intArray\" }\n    var result = -1\n    return result\n}"}
{"kt_path": "linisme__LeetCodeInKotlin__4382afc/FineMedianSortedArrays.kt", "Qwen2.5-Coder-7B-Instruct": "fun main(args: Array<String>) {\n    val solution = FindMedianSortedArraysSolution()\n    val nums1 = intArrayOf(2, 3)\n    val nums2 = intArrayOf(1, 4)\n    val median = solution.findMedianSortedArrays(nums1, nums2)\n    println(median)\n}"}
{"kt_path": "n81ur3__kotlin-coding-challenges__fdc5941/src/main/kotlin/adventofcode2018/Day18SettlersOfTheNorthPole.kt", "Qwen2.5-Coder-7B-Instruct": "package adventofcode2018\n\nimport kotlin.jvm.internal.Intrinsics\n\nfun hash(list: List<List<AreaElement>>): Int {\n    Intrinsics.checkNotNullParameter(list, \"<this>\")\n    val collection = list as Collection<*>\n    var result = 0\n    val array = collection.toArray(arrayOfNulls<Any>(0))\n    return Arrays.deepHashCode(array)\n}"}
{"kt_path": "iafsilva__codility-lessons__5d86aef/src/main/kotlin/lesson3/PermMissingElem.kt", "Qwen2.5-Coder-7B-Instruct": "package lesson3\n\nclass PermMissingElem {\n\n    fun solution(a: IntArray): Int {\n        requireNotNull(a) { \"a\" }\n        if (a.isEmpty()) return 1\n        if (a.size == 1) return if (a[0] == 1) 2 else 1\n\n        a.sort()\n\n        var i = 0\n        val n = a.size\n\n        while (i < n) {\n            if (a[i] != i + 1) {\n                return i + 1\n            }\n            i++\n        }\n\n        return n + 1\n    }\n}"}
{"kt_path": "getnahid__programing-problem-solves-kotlin__589c392/OddOccurrencesInArray.kt", "Qwen2.5-Coder-7B-Instruct": "fun solution(A: IntArray): Int {\n    requireNotNull(A) { \"array\" }\n    A.sort()\n    val n = A.size\n    var i = 0\n    while (i < n - 1) {\n        if (A[i] != A[i + 1]) return A[i]\n        i += 2\n    }\n    return A[n - 1]\n}"}
{"kt_path": "rupeshsasne__coursera-algorithms-part1__341634c/classroom/src/main/kotlin/com/radix2/algorithms/week3/SortingLinkedList.kt", "Qwen2.5-Coder-7B-Instruct": "package com.radix2.algorithms.week3\n\nfun main(args: Array<String>) {\n    val linkedList = LinkedList()\n    var i = 0\n    while (i < 11) {\n        linkedList.add(i)\n        i++\n    }\n    linkedList.reverseRecursive()\n    println(linkedList)\n}"}
{"kt_path": "boris920308__HoOne__8881468/hoon/HoonAlgorithm/src/main/kotlin/boj/week02/recursive_function/FibonacciSequence5.kt", "Qwen2.5-Coder-7B-Instruct": "fun main() {\n    val scanner = Scanner(System.`in`)\n    val n = scanner.nextInt()\n    println(fibonacci(n))\n}\n\nfun fibonacci(n: Int): Int {\n    return if (n <= 1) n else fibonacci(n - 1) + fibonacci(n - 2)\n}"}
{"kt_path": "Codextor__kotlin-codes__68b75a7/src/main/kotlin/PerfectSquares.kt", "Qwen2.5-Coder-7B-Instruct": "fun numSquares(n: Int): Int {\n    val dp = IntArray(n + 1)\n    for (i in 1..n) {\n        dp[i] = Int.MAX_VALUE\n    }\n    var i = 1\n    while (i * i <= n) {\n        for (j in i * i..n) {\n            dp[j] = minOf(dp[j], dp[j - i * i] + 1)\n        }\n        i++\n    }\n    return dp[n]\n}"}
{"kt_path": "Laomedeia__Java8InAction__0dcd843/src/main/java/leetcode/a167_twoSumInputSortArray_SIMPLE/Solution.kt", "Qwen2.5-Coder-7B-Instruct": "package leetcode.a167_twoSumInputSortArray_SIMPLE\n\nclass Solution {\n    fun twoSum(numbers: IntArray, target: Int): IntArray {\n        requireNotNull(numbers) { \"numbers\" }\n        var left = 0\n        var right = numbers.size - 1\n        while (left < right) {\n            val sum = numbers[left] + numbers[right]\n            when {\n                sum == target -> return intArrayOf(left + 1, right + 1)\n                sum < target -> left++\n                else -> right--\n            }\n        }\n        return intArrayOf()\n    }\n}"}
{"kt_path": "ariannysOronoz__tutorialKotlin__a779f54/CombinacionesPalabras/src/main/java/Main.kt", "Qwen2.5-Coder-7B-Instruct": "package com.includehelp.basic\n\nfun main(args: Array<String>) {\n    val permutation = Permutation()\n    val input1 = \"CARACOL\"\n    val length1 = input1.length\n    permutation.findPermutation(input1, 0, length1 - 1)\n\n    val input2 = \"caracol\"\n    val length2 = input2.length\n    permutation.findPermutation(input2, 0, length2 - 1)\n}\n\nclass Permutation {\n    fun findPermutation(str: String, l: Int, r: Int) {\n        if (l == r) {\n            println(str)\n        } else {\n            for (i in l..r) {\n                str = swap(str, l, i)\n                findPermutation(str, l + 1, r)\n                str = swap(str, l, i) // backtrack\n            }\n        }\n    }\n\n    private fun swap(a: String, i: Int, j: Int): String {\n        val charArray = a.toCharArray()\n        val temp = charArray[i]\n        charArray[i] = charArray[j]\n        charArray[j] = temp\n        return String(charArray)\n    }\n}"}
{"kt_path": "scientificCommunity__blog-sample__36e291c/algorithms/src/main/kotlin/org/baichuan/sample/algorithms/leetcode/middle/MaxArea.kt", "Qwen2.5-Coder-7B-Instruct": "package org.baichuan.sample.algorithms.leetcode.middle\n\nclass MaxArea {\n\n    fun maxArea(height: IntArray): Int {\n        requireNotNull(height) { \"height\" }\n        var left = 0\n        var right = 0\n        val n = height.size - 1\n        var maxArea = 0\n        var width = 1\n\n        while (left < n) {\n            if (height[left] <= height[right]) {\n                width = n - left\n                maxArea = kotlin.math.max(maxArea, height[left] * width)\n                left++\n            } else {\n                width = n - right\n                maxArea = kotlin.math.max(maxArea, height[right] * width)\n                right++\n            }\n        }\n\n        return maxArea\n    }\n}"}
{"kt_path": "boris920308__HoOne__8881468/hoon/HoonAlgorithm/src/main/kotlin/programmers/lv01/Lv1_70128.kt", "Qwen2.5-Coder-7B-Instruct": "package main.kotlin.programmers.lv01\n\nfun main() {\n    val arr1 = intArrayOf(1, 2, 3, 4)\n    val arr2 = intArrayOf(-3, -1, 0, 2)\n    solution(arr1, arr2)\n}\n\nprivate fun solution(arr1: IntArray, arr2: IntArray): Int {\n    var result = 0\n    var index = 0\n    while (index < arr1.size) {\n        result += arr1[index] * arr2[index]\n        index++\n    }\n    return result\n}"}
{"kt_path": "kotler-dev__kotlin-leetcode__0659e72/src/main/kotlin/exercise/easy/id121/Solution121.kt", "Qwen2.5-Coder-7B-Instruct": "package exercise.easy.id121\n\nclass Solution121 {\n\n    fun maxProfit(prices: IntArray): Int {\n        requireNotNull(prices) { \"prices\" }\n        if (prices.size < 2) return 0\n\n        var profit = 0\n        var minPrice = Int.MAX_VALUE\n        var maxProfit = 0\n\n        for (i in prices.indices) {\n            if (prices[i] < minPrice) {\n                minPrice = prices[i]\n                maxProfit = 0\n            } else if (prices[i] - minPrice > maxProfit) {\n                maxProfit = prices[i] - minPrice\n                profit = Math.max(profit, maxProfit)\n            }\n        }\n\n        return profit\n    }\n}"}
{"kt_path": "marc-bouvier-katas__Kotlin_EduTools_Advent_of_Code_2021__12cf74c/Day 5/Part 1/src/Task.kt", "Qwen2.5-Coder-7B-Instruct": "import kotlin.jvm.internal.Intrinsics\n\nfun overlaps(lines: Array<String>): Int {\n    Intrinsics.checkNotNullParameter(lines, \"ventsLines\")\n    val linesObj = Lines(null, 1, null)\n    if (lines.size < 2) return 0\n    var length = lines.size\n    var index = 0\n    while (index < length) {\n        val lineIndex = index\n        var j = 0\n        while (j < length) {\n            if (lineIndex != j) {\n                val lineOfVent = LineOfVent.Companion.fromString(lines[j])\n                val line = Line$Companion.fromLineOfVent(lineOfVent)\n                linesObj.mergeWith(line)\n            }\n            j++\n        }\n        index++\n    }\n    return linesObj.overlaps()\n}"}
{"kt_path": "Laomedeia__Java8InAction__0dcd843/src/main/java/leetcode/a392_isSubSequence_HARD/Solution.kt", "Qwen2.5-Coder-7B-Instruct": "class Solution {\n    fun isSubsequence(s: String, t: String): Boolean {\n        requireNotNull(s) { \"s\" }\n        requireNotNull(t) { \"t\" }\n\n        if (s.isEmpty()) return true\n\n        var i = 0\n        var j = 0\n\n        while (j < t.length) {\n            if (i == s.length) return true\n            if (s[i] == t[j]) {\n                i++\n            }\n            j++\n        }\n\n        return i == s.length\n    }\n}"}
{"kt_path": "nickperov__Algorithms__6696f5d/fibonacci/src/main/kotlin/com/nickperov/stud/algorithms/fibonacci/FibonacciLargeGenerator.kt", "Qwen2.5-Coder-7B-Instruct": "package com.nickperov.stud.algorithms.fibonacci\n\nimport java.math.BigInteger\n\nabstract class FibonacciLargeGenerator {\n    constructor()\n\n    abstract fun calculate(n: Int): BigInteger\n}\n\nclass FibonacciLargeTailRecursiveOptimisedGenerator : FibonacciLargeGenerator() {\n    override fun calculate(n: Int): BigInteger {\n        tailrec fun fib(a: BigInteger, b: BigInteger, n: Int): BigInteger = when (n) {\n            0 -> a\n            else -> fib(b, a + b, n - 1)\n        }\n        return fib(BigInteger.ZERO, BigInteger.ONE, n)\n    }\n}\n\nfun main() {\n    println(\"Hello, large Fibonacci numbers\")\n    val generator = FibonacciLargeTailRecursiveOptimisedGenerator()\n    val result = generator.calculate(1000000)\n    println(result)\n}"}
{"kt_path": "TonnyL__Windary__39f85cd/Kotlin/src/UniqueBinarySearchTrees.kt", "Qwen2.5-Coder-7B-Instruct": "class UniqueBinarySearchTrees {\n    fun numTrees(n: Int): Int {\n        val dp = IntArray(n + 1)\n        for (i in 0..n) {\n            dp[i] = 0\n        }\n        dp[0] = 1\n        dp[1] = 1\n        for (i in 2..n) {\n            for (j in 0 until i) {\n                dp[i] += dp[j] * dp[i - j - 1]\n            }\n        }\n        return dp[n]\n    }\n}"}
{"kt_path": "quincy__euler-kotlin__01d96f6/src/main/kotlin/com/quakbo/euler/Euler4.kt", "Qwen2.5-Coder-7B-Instruct": "package com.quakbo.euler\n\nfun isPalindrome(number: Int): Boolean {\n    val str = number.toString()\n    return str == str.reversed()\n}\n\nfun main(args: Array<String>) {\n    requireNotNull(args[0]) { \"args\" }\n    var i = 999\n    while (i >= 899) {\n        var j = 999\n        while (j >= 899) {\n            val product = i * j\n            if (isPalindrome(product)) {\n                println(product)\n            }\n            j--\n        }\n        i--\n    }\n}"}
{"kt_path": "getupminaaa__Algorithm__01187e2/Algorithm/src/main/kotlin/programmers/level1/personalInfoCollectionValidityPeriod.kt", "Qwen2.5-Coder-7B-Instruct": "fun main() {\n    val solution = Solution()\n    val array1 = arrayOf(\"A 6\", \"B 12\", \"C 3\")\n    val array2 = arrayOf(\"2021.05.02 A\", \"2021.07.01 B\", \"2022.02.19 C\", \"2022.02.20 C\")\n    solution.solution(\"2022.05.19\", array1, array2)\n}"}
{"kt_path": "iafsilva__codility-lessons__5d86aef/src/main/kotlin/lesson1/BinaryGap.kt", "Qwen2.5-Coder-7B-Instruct": "class BinaryGap {\n    fun solution(n: Int): Int {\n        var maxGap = 0\n        var currentGap = 0\n        var inGap = false\n\n        val binaryString = Integer.toBinaryString(n)\n        for (char in binaryString) {\n            when (char) {\n                '1' -> {\n                    if (!inGap) {\n                        inGap = true\n                    } else {\n                        maxGap = maxOf(maxGap, currentGap)\n                        currentGap = 0\n                    }\n                }\n                '0' -> {\n                    if (inGap) {\n                        currentGap++\n                    }\n                }\n            }\n        }\n\n        return maxOf(maxGap, currentGap)\n    }\n}"}
{"kt_path": "zys0909__CodeLabs__869c7c2/src/com/leecode/array/Code1.kt", "Qwen2.5-Coder-7B-Instruct": "package com.leecode.array\n\nfun missingNumber1(nums: IntArray): Int {\n    kotlin.jvm.internal.Intrinsics.checkNotNullParameter(nums, \"nums\")\n    var sum = 0\n    var index = 0\n    val length = nums.size\n    while (index < length) {\n        val num = nums[index]\n        if (num != sum) {\n            return sum\n        }\n        sum++\n        index++\n    }\n    return sum\n}\n\nfun missingNumber2(nums: IntArray): Int {\n    kotlin.jvm.internal.Intrinsics.checkNotNullParameter(nums, \"nums\")\n    var sum = 0\n    var index = 0\n    val length = nums.size - 1\n    while (index <= length) {\n        val num = nums[index]\n        if (num != index + 1) {\n            return index + 1\n        }\n        index++\n    }\n    return index + 1\n}"}
{"kt_path": "ykrytsyn__leetcode-in-kotlin__0acf2a6/src/main/kotlin/leetcode/ArrangingCoins.kt", "Qwen2.5-Coder-7B-Instruct": "package leetcode\n\nclass ArrangingCoins {\n\n    init {\n        // Constructor implementation\n    }\n\n    fun bruteForce(n: Int): Int {\n        var count = n\n        while (count > 1) {\n            if (count == 1) return count\n            count--\n        }\n        return 0\n    }\n\n    fun binarySearch(n: Int): Int {\n        var left = 0L\n        var right = n.toLong()\n        var mid = 0L\n        while (left <= right) {\n            mid = (left + right) / 2\n            val sum = mid * (mid + 1) / 2\n            if (sum == n.toLong()) return mid.toInt()\n            if (sum < n.toLong()) {\n                left = mid + 1\n            } else {\n                right = mid - 1\n            }\n        }\n        return left.toInt()\n    }\n}"}
{"kt_path": "mayabot__mynlp__b980da3/mynlp/src/main/java/com/mayabot/nlp/module/nwd/ValueObjects.kt", "Qwen2.5-Coder-7B-Instruct": "package com.mayabot.nlp.module.nwd\n\nimport kotlin.jvm.internal.Intrinsics\n\nfun addTo(map: HashMap<Character, IntCount>, key: Char, value: Int) {\n    Intrinsics.checkNotNullParameter(map, \"<this>\")\n    val mapInterface = map as Map<Any?, Any?>\n    val characterKey = Character.valueOf(key)\n    var count = 0\n    val existingValue = mapInterface[characterKey]\n    if (existingValue == null) {\n        count = 0\n        val newIntCount = IntCount()\n        mapInterface[characterKey] = newIntCount\n        count = newIntCount.value\n    } else {\n        count = existingValue as IntCount\n        count.value += value\n    }\n}"}
{"kt_path": "jjrodcast__CompetitiveProblems__a91868c/leetcode/UniquePathsTwo.kt", "Qwen2.5-Coder-7B-Instruct": "fun main() {\n    val solution = Solution()\n    val obstacleGrid = arrayOf(\n        intArrayOf(0, 0, 0),\n        intArrayOf(0, 1, 0),\n        intArrayOf(0, 0, 0)\n    )\n    val result = solution.uniquePathsWithObstacles(obstacleGrid)\n    println(result)\n}\n\nclass Solution {\n    fun uniquePathsWithObstacles(obstacleGrid: Array<IntArray>): Int {\n        // Implementation of uniquePathsWithObstacles method goes here\n        return 0 // Placeholder return value\n    }\n}"}
{"kt_path": "boris920308__HoOne__8881468/hoon/HoonAlgorithm/src/main/kotlin/programmers/lv01/Lv1_77884.kt", "Qwen2.5-Coder-7B-Instruct": "package main.kotlin.programmers.lv01\n\nfun main() {\n    val result = solution(13, 17)\n}\n\nprivate fun solution(a: Int, b: Int): Int {\n    var sum = 0\n    var start = a\n    while (start <= b) {\n        if (start % 2 == 0) {\n            sum += start\n        } else {\n            sum -= start\n        }\n        start++\n    }\n    println(sum)\n    return sum\n}\n\nprivate fun countDivisors(n: Int): Int {\n    var count = 0\n    val sqrtN = Math.sqrt(n.toDouble()).toInt()\n    var i = 1\n    while (i <= sqrtN) {\n        if (n % i == 0) {\n            count += if (i == n / i) 1 else 2\n        }\n        i++\n    }\n    return count\n}"}
{"kt_path": "Codextor__kotlin-codes__68b75a7/src/main/kotlin/PartitionArrayForMaximumSum.kt", "Qwen2.5-Coder-7B-Instruct": "fun maxSumAfterPartitioning(arr: IntArray, k: Int): Int {\n    requireNotNull(arr) { \"arr\" }\n    val n = arr.size\n    val dp = IntArray(n + 1)\n    var i = 1\n    while (i <= n) {\n        var j = 1\n        var maxVal = 0\n        while (j <= k && i - j >= 0) {\n            maxVal = maxOf(maxVal, arr[i - j])\n            dp[i] = maxOf(dp[i], dp[i - j] + maxVal * j)\n            j++\n        }\n        i++\n    }\n    return dp[n]\n}"}
{"kt_path": "scientificCommunity__blog-sample__36e291c/algorithms/src/main/kotlin/org/baichuan/sample/algorithms/leetcode/simple/interview/MajorityElement.kt", "Qwen2.5-Coder-7B-Instruct": "package org.baichuan.sample.algorithms.leetcode.simple.interview\n\nclass MajorityElement {\n\n    fun majorityElement(nums: IntArray): Int {\n        requireNotNull(nums) { \"nums\" }\n        var count = 0\n        var candidate = 0\n        for (num in nums) {\n            if (count == 0) {\n                candidate = num\n                count = 1\n            } else {\n                count += if (candidate == num) 1 else -1\n            }\n        }\n\n        count = 0\n        for (num in nums) {\n            if (num == candidate) {\n                count++\n            }\n        }\n\n        return if (count > nums.size / 2) candidate else -1\n    }\n}"}
{"kt_path": "rhavran__ProjectEuler__1115674/src/Utils.kt", "Qwen2.5-Coder-7B-Instruct": "object UtilsKt {\n    fun dividers(n: Long): Long {\n        var result = 1L\n        val primeFactorization = PrimeFactorization.INSTANCE.primeFactors(n)\n        for ((key, value) in primeFactorization.entries) {\n            result *= (value + 1)\n        }\n        return result\n    }\n\n    fun sequenceSumStartingFrom(start: Long, end: Long): Long {\n        return start + sumFromTo(start, end)\n    }\n\n    private fun sumFromTo(from: Long, to: Long): Long {\n        val n = to - from + 1\n        val sum = (n * (from + to)) / 2\n        return sum\n    }\n}"}
{"kt_path": "jimmymorales__project-euler__e881cad/src/main/kotlin/Problem4.kt", "Qwen2.5-Coder-7B-Instruct": "fun largestPalindrome(): Int {\n    var max = 0\n    var i = 999\n    while (i >= 100) {\n        var j = 999\n        while (j > i) {\n            val product = i * j\n            if (product <= max) break\n            if (isPalindrome(product)) {\n                max = product\n            }\n            j--\n        }\n        i--\n    }\n    return max\n}\n\nfun isPalindrome(number: Int): Boolean {\n    return number == reverse(number)\n}\n\nfun reverse(number: Int): Int {\n    var reversed = 0\n    var n = number\n    while (n > 0) {\n        reversed = reversed * 10 + n % 10\n        n /= 10\n    }\n    return reversed\n}\n\nfun main(args: Array<String>) {\n    println(largestPalindrome())\n}"}
{"kt_path": "Codextor__kotlin-codes__68b75a7/src/main/kotlin/PalindromicSubstrings.kt", "Qwen2.5-Coder-7B-Instruct": "fun countSubstrings(s: String): Int {\n    requireNotNull(s) { \"s\" }\n    var count = 0\n    var left = 0\n    val n = s.length\n    while (left < n) {\n        count += countSubstringsWithCenter(s, left, left)\n        count += countSubstringsWithCenter(s, left, left + 1)\n        left++\n    }\n    return count\n}\n\nprivate fun countSubstringsWithCenter(s: String, left: Int, right: Int): Int {\n    var result = 0\n    var l = left\n    var r = right\n    while (l >= 0 && r < s.length && s[l] == s[r]) {\n        result++\n        l--\n        r++\n    }\n    return result\n}"}
{"kt_path": "antop-dev__algorithm__9a3e762/src/main/kotlin/kr/co/programmers/P12952.kt", "Qwen2.5-Coder-7B-Instruct": "package kr.co.programmers\n\nclass P12952 {\n\n    fun solution(n: Int): Int {\n        val arr = IntArray(n)\n        return dfs(arr, 0)\n    }\n\n    private fun dfs(arr: IntArray, index: Int): Int {\n        if (index == arr.size) {\n            return 1\n        }\n        var result = 0\n        for (i in 0 until arr.size) {\n            arr[index] = i\n            if (valid(arr, index)) {\n                result += dfs(arr, index + 1)\n            }\n        }\n        return result\n    }\n\n    private fun valid(arr: IntArray, index: Int): Boolean {\n        for (i in 0..index) {\n            if (arr[i] != arr[index]) continue\n            if (Math.abs(index - i) == Math.abs(arr[index] - arr[i])) {\n                return false\n            }\n        }\n        return true\n    }\n}"}
{"kt_path": "ILIYANGERMANOV__algorithms__4abe4b5/Algorithms/src/main/kotlin/MaxSubArray.kt", "Qwen2.5-Coder-7B-Instruct": "class MaxSubArray {\n    fun maxSubArray(nums: IntArray): Int {\n        requireNotNull(nums) { \"nums\" }\n        val n = nums.size\n        if (n == 1) return nums[0]\n        \n        var currentSum = nums[0]\n        var globalSum = nums[0]\n        var i = 1\n        \n        while (i < n) {\n            val num = nums[i]\n            currentSum = if (num > currentSum + num) num else currentSum + num\n            globalSum = Math.max(globalSum, currentSum)\n            i++\n        }\n        \n        return globalSum\n    }\n}"}
{"kt_path": "AlBovo__Compiti__56a3131/src/main/kotlin/segtree.kt", "Qwen2.5-Coder-7B-Instruct": "fun main(args: Array<String>) {\n    val arr = arrayOf(\n        Integer.valueOf(2),\n        Integer.valueOf(4),\n        Integer.valueOf(2),\n        Integer.valueOf(1),\n        Integer.valueOf(3),\n        Integer.valueOf(4),\n        Integer.valueOf(5)\n    )\n    val segtree = SegmentTree(arr)\n    val sum = segtree.getSum(0, 4)\n    System.out.print(sum)\n}"}
{"kt_path": "3mtee__exercism-kotlin__6e3eb88/complex-numbers/src/main/kotlin/ComplexNumbers.kt", "Qwen2.5-Coder-7B-Instruct": "import kotlin.jvm.internal.Intrinsics\n\nfun exponential(c: ComplexNumber): ComplexNumber {\n    Intrinsics.checkNotNullParameter(c, \"c\")\n    val real = c.real\n    return if (real == 0.0) {\n        ComplexNumber(Math.cos(c.imag), Math.sin(c.imag))\n    } else {\n        val exp = Math.exp(real)\n        ComplexNumber(exp * Math.cos(c.imag), exp * Math.sin(c.imag))\n    }\n}"}
{"kt_path": "perihanmirkelam__ProjectEuler__a24ac44/src/main/kotlin/P014_LongestCollatzSequence.kt", "Qwen2.5-Coder-7B-Instruct": "fun p14() {\n    var longestChainLength = 0L\n    var numberWithLongestChain = 0\n    var currentNumber = 0\n    var chainLength = 0\n\n    val limit = 1000000\n    var i = 0\n\n    while (i < limit) {\n        var n = i\n        chainLength = 0\n\n        while (n > 0) {\n            currentNumber = n\n            chainLength++\n\n            if (currentNumber == 1) {\n                break\n            }\n\n            if (currentNumber % 2 == 0) {\n                currentNumber /= 2\n            } else {\n                currentNumber = 3 * currentNumber + 1\n            }\n        }\n\n        if (chainLength > longestChainLength) {\n            longestChainLength = chainLength\n            numberWithLongestChain = i\n        }\n\n        i++\n    }\n\n    println(\"A14:$numberWithLongestChain\")\n}"}
{"kt_path": "iafsilva__codility-lessons__5d86aef/src/main/kotlin/lesson2/CyclicRotation.kt", "Qwen2.5-Coder-7B-Instruct": "package lesson2\n\nclass CyclicRotation {\n\n    fun solution(a: IntArray, k: Int): IntArray {\n        requireNotNull(a) { \"a\" }\n        if (k == 0 || a.isEmpty()) return a\n        val n = a.size\n        if (n == 1) return a\n        val rotation = if (k % n == 0) 0 else k % n\n        val deque = a.toList().toMutableList()\n        for (i in 1..rotation) {\n            deque.addFirst(deque.removeLast())\n        }\n        return deque.toIntArray()\n    }\n}"}
{"kt_path": "boris920308__HoOne__8881468/hoon/HoonAlgorithm/src/main/kotlin/programmers/lv01/Lv1_12912.kt", "Qwen2.5-Coder-7B-Instruct": "package main.kotlin.programmers.lv01\n\nfun main() {\n    solution(3, 5)\n    solution(3, 3)\n    solution(5, 3)\n}\n\nprivate fun solution(a: Int, b: Int): Long {\n    var sum = 0L\n    var start = a\n    var end = b\n    if (start > end) {\n        start = b\n        end = a\n    }\n    while (start <= end) {\n        sum += start\n        start++\n    }\n    return sum\n}\n\nprivate fun secondSolution(a: Int, b: Int): Long {\n    if (a <= b) {\n        return (a..b).sumOf { it.toLong() }\n    } else {\n        return (b..a).sumOf { it.toLong() }\n    }\n}"}
{"kt_path": "darian-catalin-cucer__divide-and-conquer-algorithms__1cea70d/kt.kt", "Qwen2.5-Coder-7B-Instruct": "import kotlin.jvm.internal.Intrinsics\n\nfun quickSort(arr: IntArray, low: Int, high: Int) {\n    Intrinsics.checkNotNullParameter(arr, \"arr\")\n    if (low < high) {\n        val pi = partition(arr, low, high)\n        quickSort(arr, low, pi - 1)\n        quickSort(arr, pi + 1, high)\n    }\n}\n\nprivate fun partition(arr: IntArray, low: Int, high: Int): Int {\n    Intrinsics.checkNotNullParameter(arr, \"arr\")\n    val pivot = arr[high]\n    var i = low - 1\n    var j = low\n    while (j < high) {\n        if (arr[j] <= pivot) {\n            i++\n            val temp = arr[i]\n            arr[i] = arr[j]\n            arr[j] = temp\n        }\n        j++\n    }\n    val temp = arr[i + 1]\n    arr[i + 1] = arr[high]\n    arr[high] = temp\n    return i + 1\n}"}
{"kt_path": "TonnyL__Windary__39f85cd/Kotlin/src/ThreeSumClosest.kt", "Qwen2.5-Coder-7B-Instruct": "class ThreeSumClosest {\n    fun threeSumClosest(nums: IntArray, target: Int): Int {\n        requireNotNull(nums) { \"nums\" }\n        nums.sort()\n        \n        var closest = nums[0] + nums[1] + nums[2]\n        \n        var left = 0\n        var right = nums.size - 1\n        \n        while (left < right) {\n            for (i in left until right) {\n                val sum = nums[left] + nums[i] + nums[right]\n                \n                if (sum == target) {\n                    return sum\n                } else if (Math.abs(sum - target) < Math.abs(closest - target)) {\n                    closest = sum\n                }\n                \n                if (sum < target) {\n                    left++\n                } else {\n                    right--\n                }\n            }\n            \n            if (closest == target) {\n                return closest\n            } else if (Math.abs(closest - target) > Math.abs(target - (nums[left] + nums[left + 1] + nums[right]))) {\n                closest = nums[left] + nums[left + 1] + nums[right]\n            } else if (Math.abs(closest - target) > Math.abs(target - (nums[left] + nums[right] + nums[right - 1]))) {\n                closest = nums[left] + nums[right] + nums[right - 1]\n            }\n            \n            if (closest == target) {\n                return closest\n            } else if (Math.abs(closest - target) > Math.abs(target - (nums[left + 1] + nums[left + 2] + nums[right]))) {\n                closest = nums[left + 1] + nums[left + 2] + nums[right]\n            } else if (Math.abs(closest - target) > Math.abs(target - (nums[left] + nums[right - 1] + nums[right]))) {\n                closest = nums[left] + nums[right - 1] + nums[right]\n            }\n            \n            left++\n            right--\n        }\n        \n        return closest\n    }\n}"}
{"kt_path": "Javran__leetcode__f3899fe/bulb-switcher/Solution.kt", "Qwen2.5-Coder-7B-Instruct": "class Solution {\n    companion object {\n        val Companion = this::class.java.enclosingClass?.kotlin?.companionObject ?: throw IllegalStateException(\"Companion object not found\")\n\n        fun main(args: Array<String>) {\n            checkNotNull(args[0], \"args\")\n            val solution = Solution()\n            val result = solution.bulbSwitch(10)\n            println(result)\n        }\n    }\n\n    init {\n        // Constructor body (if needed)\n    }\n\n    fun bulbSwitch(n: Int): Int {\n        return Math.floor(Math.sqrt(n.toDouble())).toInt()\n    }\n}"}
{"kt_path": "TonnyL__Windary__39f85cd/Kotlin/src/NextPermutation.kt", "Qwen2.5-Coder-7B-Instruct": "class NextPermutation {\n\n    fun nextPermutation(nums: IntArray) {\n        requireNotNull(nums) { \"nums\" }\n        var i = nums.size - 2\n        while (i >= 0 && nums[i] >= nums[i + 1]) {\n            i--\n        }\n        if (i >= 0) {\n            var j = nums.size - 1\n            while (j > i && nums[j] <= nums[i]) {\n                j--\n            }\n            swap(nums, i, j)\n        }\n        reverse(nums, i + 1, nums.size - 1)\n    }\n\n    private fun swap(nums: IntArray, i: Int, j: Int) {\n        val temp = nums[i]\n        nums[i] = nums[j]\n        nums[j] = temp\n    }\n\n    private fun reverse(nums: IntArray, start: Int, end: Int) {\n        var left = start\n        var right = end\n        while (left < right) {\n            swap(nums, left, right)\n            left++\n            right--\n        }\n    }\n}"}
{"kt_path": "boris920308__HoOne__8881468/hoon/HoonAlgorithm/src/main/kotlin/programmers/lv01/Lv1_12940.kt", "Qwen2.5-Coder-7B-Instruct": "package main.kotlin.programmers.lv01\n\nfun main() {\n    val result = solution(3, 12)\n    println(\" - - - - - - - - - -\")\n    val result2 = solution(2, 5)\n    println(\" - - - - - - - - - -\")\n}\n\nprivate fun solution(a: Int, b: Int): List<Int> {\n    val array = IntArray(2)\n    array[0] = 0\n    array[1] = 0\n    array[0] = findGCD(a, b)\n    array[1] = findLCM(a, b)\n    return array.toList()\n}\n\nprivate fun findGCD(a: Int, b: Int): Int {\n    var temp = b\n    while (temp != 0) {\n        temp = a % b\n        a = b\n        b = temp\n    }\n    return a\n}\n\nprivate fun findLCM(a: Int, b: Int): Int {\n    return (a * b) / findGCD(a, b)\n}"}
{"kt_path": "JiangKlijna__leetcode-learning__65a1348/kt/001 Two Sum/TwoSum.kt", "Qwen2.5-Coder-7B-Instruct": "class TwoSum {\n    fun twoSum(numbers: IntArray, target: Int): IntArray {\n        requireNotNull(numbers) { \"numbers\" }\n        val result = IntArray(2)\n        val map = HashMap<Int, Int>()\n        var i = 0\n        while (i < numbers.size) {\n            val complement = target - numbers[i]\n            if (map.containsKey(complement)) {\n                result[0] = map[complement]!!\n                result[1] = i\n                return result\n            } else {\n                map[numbers[i]] = i\n            }\n            i++\n        }\n        return result\n    }\n}"}
{"kt_path": "rupeshsasne__coursera-algorithms-part1__341634c/classroom/src/main/kotlin/com/radix2/algorithms/week1/UnionFind.kt", "Qwen2.5-Coder-7B-Instruct": "package com.radix2.algorithms.week1\n\nfun main(args: Array<String>) {\n    val uf = WeightedQuickUnionWithPathCompressionUF(10)\n    uf.union(4, 3)\n    uf.union(3, 8)\n    uf.union(6, 5)\n    uf.union(9, 4)\n    uf.union(2, 1)\n    uf.union(5, 0)\n    uf.union(7, 2)\n    uf.union(6, 1)\n    uf.union(7, 3)\n}"}
{"kt_path": "boris920308__HoOne__8881468/hoon/HoonAlgorithm/src/main/kotlin/programmers/lv01/Lv1_68935.kt", "Qwen2.5-Coder-7B-Instruct": "package main.kotlin.programmers.lv01\n\nfun main(args: Array<String>) {\n    solution(45)\n}\n\nprivate fun solution(number: Int): Int {\n    val str = number.toString(3).reversed()\n    return Integer.parseInt(str, 3)\n}\n\nprivate fun solution_1(number: Int): Int {\n    val str = number.toString(3).reversed()\n    return Integer.parseInt(str, 10)\n}"}
{"kt_path": "korilin__DSA-kt__b96ba1b/src/main/kotlin/sort_algorithm/quickSort.kt", "Qwen2.5-Coder-7B-Instruct": "package sort_algorithm\n\nfun quickSort(array: IntArray) {\n    requireNotNull(array) { \"array\" }\n    quickSortInner(array, 0, array.size - 1)\n}\n\nprivate fun quickSortInner(array: IntArray, low: Int, high: Int) {\n    if (low < high) {\n        val partitionIndex = quickSortPartition(array, low, high)\n        quickSortInner(array, low, partitionIndex - 1)\n        quickSortInner(array, partitionIndex + 1, high)\n    }\n}\n\nprivate fun quickSortPartition(array: IntArray, low: Int, high: Int): Int {\n    var i = low - 1\n    var j = low\n    while (j < high) {\n        if (array[j] <= array[high]) {\n            i++\n            val temp = array[i]\n            array[i] = array[j]\n            array[j] = temp\n        }\n        j++\n    }\n    val temp = array[i + 1]\n    array[i + 1] = array[high]\n    array[high] = temp\n    return i + 1\n}"}
{"kt_path": "gardnerdickson__advent-of-code-2015__4a23ab3/src/day_10.kt", "Qwen2.5-Coder-7B-Instruct": "fun main(args: Array<String>) {\n    val input = \"1113222113\"\n    val day10Instance = Day10.INSTANCE\n\n    val part1Result = day10Instance.part1(input)\n    println(\"Part 1: $part1Result\")\n\n    val part2Result = day10Instance.part2(input)\n    println(\"Part 2: $part2Result\")\n}"}
{"kt_path": "gardnerdickson__advent-of-code-2015__4a23ab3/src/day_2.kt", "Qwen2.5-Coder-7B-Instruct": "fun main(args: Array<String>) {\n    val file = \"res/day_2_input.txt\"\n    val part1Result = Day2.INSTANCE.part1(file)\n    println(\"Part 1: $part1Result\")\n    \n    val part2Result = Day2.INSTANCE.part2(file)\n    println(\"Part 2: $part2Result\")\n}"}
{"kt_path": "gardnerdickson__advent-of-code-2015__4a23ab3/src/day_3.kt", "Qwen2.5-Coder-7B-Instruct": "fun main(args: Array<String>) {\n    val file = \"res/day_3_input.txt\"\n    val part1Result = Day3.INSTANCE.part1(file)\n    println(\"Part 1: $part1Result\")\n    \n    val part2Result = Day3.INSTANCE.part2(file)\n    println(\"Part 2: $part2Result\")\n}"}
{"kt_path": "antop-dev__algorithm__9a3e762/src/main/kotlin/kr/co/programmers/P161988.kt", "Qwen2.5-Coder-7B-Instruct": "package kr.co.programmers\n\nclass P161988 {\n\n    init {\n        // Constructor does nothing\n    }\n\n    fun solution(array: IntArray): Long {\n        checkNotNull(array, \"sequence\")\n        val maxPositive = max(array, 1)\n        val maxNegative = max(array, -1)\n        return Math.max(maxPositive, maxNegative)\n    }\n\n    private fun max(array: IntArray, multiplier: Int): Long {\n        val length = array.size\n        val resultArray = LongArray(length)\n        var currentMax = if (multiplier == 1) Long.MIN_VALUE else Long.MAX_VALUE\n        var index = 0\n\n        while (index < length) {\n            resultArray[index] = array[index].toLong() * multiplier\n            currentMax = Math.max(currentMax, resultArray[index])\n            index++\n        }\n\n        index = 1\n        while (index < length) {\n            resultArray[index] = Math.max(resultArray[index], resultArray[index - 1] + resultArray[index])\n            currentMax = Math.max(currentMax, resultArray[index])\n            index++\n        }\n\n        return currentMax\n    }\n}"}
{"kt_path": "alexjlockwood__bees-and-bombs-compose__0d7a86b/app/src/main/java/com/alexjlockwood/beesandbombs/demos/utils/MathUtils.kt", "Qwen2.5-Coder-7B-Instruct": "package com.alexjlockwood.beesandbombs.demos.utils\n\nobject MathUtilsKt {\n    val PI = Math.PI.toFloat()\n    val TWO_PI = PI * 2\n    val HALF_PI = PI / 2\n\n    fun dist(x1: Float, y1: Float, x2: Float, y2: Float): Float {\n        return kotlin.math.sqrt((x2 - x1).toDouble() * (x2 - x1) + (y2 - y1).toDouble() * (y2 - y1)).toFloat()\n    }\n\n    fun lerp(start: Float, end: Float, t: Float): Float {\n        return start + (end - start) * t\n    }\n\n    fun map(value: Float, fromStart: Float, fromEnd: Float, toStart: Float, toEnd: Float): Float {\n        return toStart + (value - fromStart) * (toEnd - toStart) / (fromEnd - fromStart)\n    }\n\n    fun toDegrees(radians: Float): Float {\n        return radians.toDouble().let { Math.toDegrees(it) }.toFloat()\n    }\n\n    fun ease(t: Float): Float {\n        return 3 * t * t - 2 * t * t * t\n    }\n\n    fun ease(t: Float, amplitude: Float): Float {\n        return if (t < 0.5f) {\n            amplitude * t * t\n        } else {\n            amplitude * (1 - (1 - t) * (1 - t))\n        }\n    }\n}"}
{"kt_path": "chengw315__daily-study__501b881/letcode/src/main/java/daily/LeetCodeLCP13.kt", "Qwen2.5-Coder-7B-Instruct": "package daily\n\nclass SolutionLCP13 {\n    fun minimalSteps(steps: Array<String>): Int {\n        // Implementation of minimalSteps function\n        return 0 // Placeholder return value\n    }\n}\n\nfun main() {\n    val solution = SolutionLCP13()\n    val steps1 = arrayOf(\"S#O\", \"M..\", \"M.T\")\n    val result1 = solution.minimalSteps(steps1)\n    \n    val solution2 = SolutionLCP13()\n    val steps2 = arrayOf(\"S#O\", \"M.#\", \"M.T\")\n    val result2 = solution2.minimalSteps(steps2)\n    \n    val solution3 = SolutionLCP13()\n    val steps3 = arrayOf(\"S#O\", \"M.T\", \"M..\")\n    val result3 = solution3.minimalSteps(steps3)\n}"}
{"kt_path": "rajatenzyme__Coding-Journey__65a0570/Algo_Ds_Notes-master/Algo_Ds_Notes-master/Floyd_Warshall_Algorithm/Floyd_Warshall_Algorithm.kt", "Qwen2.5-Coder-7B-Instruct": "fun main(args: Array<String>) {\n    val matrix = arrayOf(\n        intArrayOf(3, Int.MAX_VALUE, -2),\n        intArrayOf(Int.MAX_VALUE, 1, 4),\n        intArrayOf(Int.MAX_VALUE, 3, Int.MAX_VALUE)\n    )\n    \n    FloydWarshall.INSTANCE.doCalcs(matrix, 4)\n}"}
{"kt_path": "brunorene__advent_of_code_2018__0cb6814/src/main/kotlin/advent/of/code/day17/Solution.kt", "Qwen2.5-Coder-7B-Instruct": "package advent.of.code.day17\n\nimport java.io.File\nimport kotlin.text.Regex\n\nprivate val input = File(\"day17.txt\")\nprivate val multipleCoord = Regex(\"(x|y)=([.0-9]+)\\\\.\\\\.([.0-9]+)\")\nprivate val oneCoord = Regex(\"(x|y)=([.0-9]+)\")\n\nfun getInput(): File {\n    return input\n}\n\nfun getMultipleCoord(): Regex {\n    return multipleCoord\n}\n\nfun getOneCoord(): Regex {\n    return oneCoord\n}\n\nfun part1(): Int {\n    val underground = Underground(input)\n    println(underground.clay.size)\n    return 1\n}\n\nfun part2(): Int {\n    return 2\n}"}
{"kt_path": "Simplation__OpenSourceRepository__d45feaa/算法/一维数组的动态和1480.kt", "Qwen2.5-Coder-7B-Instruct": "package com.example.rain_demo.algorithm\n\nfun main() {\n    val arr = IntArray(5)\n    arr[0] = 1\n    arr[1] = 1\n    arr[2] = 1\n    arr[3] = 1\n    arr[4] = 1\n    arr.forEach { print(\"$it \") }\n}\n\nprivate fun sumArr(newNum: IntArray, nums: IntArray, index: Int): Int {\n    checkNotNullParameter(newNum, \"newNum\")\n    checkNotNullParameter(nums, \"nums\")\n    if (index != 0) {\n        newNum[index] = nums[index] + sumArr(newNum, nums, index - 1)\n    } else {\n        newNum[0] = nums[0]\n    }\n    return newNum[index]\n}\n\nprivate fun checkNotNullParameter(value: Any?, name: String) {\n    require(value != null) { \"$name must not be null\" }\n}"}
{"kt_path": "jimmymorales__project-euler__e881cad/src/main/kotlin/Problem3.kt", "Qwen2.5-Coder-7B-Instruct": "fun main() {\n    val result = solution3(600851475143L)\n    println(result)\n}\n\nprivate fun solution3(n: Long): Long {\n    var num = n\n    while (num % 2 == 0L) {\n        num /= 2\n    }\n    var divisor = 3\n    while (divisor <= Math.sqrt(num.toDouble()).toLong()) {\n        if (num % divisor == 0L) {\n            num /= divisor\n        } else {\n            divisor += 2\n        }\n    }\n    return num\n}"}
{"kt_path": "age-series__ElectricalAge2__86d843f/src/main/kotlin/org/eln2/mc/data/SegmentTree.kt", "Qwen2.5-Coder-7B-Instruct": "package org.eln2.mc.data\n\nclass SegmentTree<T>(private val root: SegmentTreeNode<T>) {\n\n    fun queryOrNull(query: Double): T? {\n        if (root.contains(query)) {\n            return root.query(query)\n        }\n        return null\n    }\n\n    fun query(query: Double): T {\n        val result = root.query(query)\n        if (result != null) {\n            return result\n        } else {\n            throw IllegalStateException(\"$query not found\")\n        }\n    }\n}"}
{"kt_path": "ykrytsyn__leetcode-in-kotlin__0acf2a6/src/main/kotlin/leetcode/UniquePaths.kt", "Qwen2.5-Coder-7B-Instruct": "class UniquePaths {\n\n    init {\n        // Constructor body (empty in this case)\n    }\n\n    fun dynamicProgramming(m: Int, n: Int): Int {\n        var result = 0\n        val dp = Array(m) { IntArray(n) }\n        \n        for (i in 0 until m) {\n            for (j in 0 until n) {\n                if (i == 0 && j == 0) {\n                    dp[i][j] = 1\n                } else {\n                    dp[i][j] = if (i > 0) dp[i - 1][j] else 0 + if (j > 0) dp[i][j - 1] else 0\n                }\n            }\n        }\n        \n        return dp[0][0]\n    }\n\n    fun recursive(m: Int, n: Int): Int {\n        if (m == 1) return 1\n        if (n == 1) return 1\n        \n        return recursive(m - 1, n) + recursive(m, n - 1)\n    }\n}"}
{"kt_path": "quincy__euler-kotlin__01d96f6/src/main/kotlin/com/quakbo/euler/Euler6.kt", "Qwen2.5-Coder-7B-Instruct": "package com.quakbo.euler\n\nfun sumOfSquares(sequence: Sequence<Int>): Int {\n    return sequence.map { it * it }.sum()\n}\n\nfun squareOfSums(sequence: Sequence<Int>): Int {\n    val sum = sequence.sum()\n    return sum * sum\n}\n\nfun main(args: Array<String>) {\n    checkNotNull(args)\n    val sequence = generateSequence(1) { it + 1 }.take(100)\n    val result = squareOfSums(sequence) - sumOfSquares(sequence)\n    println(result)\n}"}
{"kt_path": "Kirchberg__BigDataPL__b6a459a/LR7/src/main/kotlin/Task1V3.kt", "Qwen2.5-Coder-7B-Instruct": "fun task1V3() {\n    val input = \"java android kotlin rust\"\n    val words = input.split(\" \")\n    val wordChainFinder = WordChainFinder(words)\n    val longestWordChain = wordChainFinder.findLongestWordChain()\n    val result = StringBuilder().apply {\n        append(\"Longest word chain: \")\n        append(longestWordChain.joinToString(\", \"))\n    }\n    println(result.toString())\n}"}
{"kt_path": "fredyw__leetcode__a59d77c/src/main/kotlin/leetcode/Problem2064.kt", "Qwen2.5-Coder-7B-Instruct": "package leetcode\n\nclass Problem2064 {\n\n    init {\n        // Constructor implementation\n    }\n\n    fun minimizedMaximum(k: Int, quantities: IntArray): Int {\n        require(quantities.isNotEmpty()) { \"quantities\" }\n        \n        var left = 1\n        var right = quantities.maxOrNull()!!\n        \n        while (left < right) {\n            val mid = (left + right) / 2\n            \n            if (canDistribute(k, quantities, mid)) {\n                right = mid\n            } else {\n                left = mid + 1\n            }\n        }\n        \n        return left\n    }\n\n    private fun canDistribute(k: Int, quantities: IntArray, maxPerPerson: Int): Boolean {\n        var people = 1\n        var currentLoad = 0\n        \n        for (quantity in quantities) {\n            if (currentLoad + quantity > maxPerPerson) {\n                people++\n                currentLoad = quantity\n            } else {\n                currentLoad += quantity\n            }\n            \n            if (people > k) {\n                return false\n            }\n        }\n        \n        return true\n    }\n}"}
