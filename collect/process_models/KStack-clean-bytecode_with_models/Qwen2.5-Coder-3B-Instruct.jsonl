{"kt_path": "remisultan__multiarm-bandit-algorithm-kotlin__ead934d/core-bandit/src/main/kotlin/org/rsultan/bandit/algorithms/BanditAlgorithm.kt", "Qwen2.5-Coder-3B-Instruct": "package org.rsultan.bandit.algorithms\n\ninterface BanditAlgorithm {\n    fun selectArm(): Int\n\n    fun update(arm: Int, reward: Float)\n}"}
{"kt_path": "n81ur3__kotlin-coding-challenges__fdc5941/src/main/kotlin/adventofcode2018/Day22ModeMaze.kt", "Qwen2.5-Coder-3B-Instruct": "class Day22ModeMaze() {\n    init {\n        super()\n    }\n}"}
{"kt_path": "n81ur3__kotlin-coding-challenges__fdc5941/src/main/kotlin/adventofcode2017/Day21FractalArt.kt", "Qwen2.5-Coder-3B-Instruct": "class Day21FractalArt {\n    constructor()\n}"}
{"kt_path": "n81ur3__kotlin-coding-challenges__fdc5941/src/main/kotlin/adventofcode2017/Day03SpiralMemory.kt", "Qwen2.5-Coder-3B-Instruct": "class Day03SpiralMemory {\n    constructor()\n}"}
{"kt_path": "n81ur3__kotlin-coding-challenges__fdc5941/src/main/kotlin/adventofcode2019/Day03CrossedWires.kt", "Qwen2.5-Coder-3B-Instruct": "class Day03CrossedWires"}
{"kt_path": "n81ur3__kotlin-coding-challenges__fdc5941/src/main/kotlin/adventofcode2018/Day04ReposeRecord.kt", "Qwen2.5-Coder-3B-Instruct": "class Day04ReposeRecord() {\n}"}
{"kt_path": "n81ur3__kotlin-coding-challenges__fdc5941/src/main/kotlin/adventofcode2017/Day08LikeRegisters.kt", "Qwen2.5-Coder-3B-Instruct": "class Day08LikeRegisters() {\n    init {\n        super()\n    }\n}"}
{"kt_path": "n81ur3__kotlin-coding-challenges__fdc5941/src/main/kotlin/adventofcode2018/Day11ChronalCharge.kt", "Qwen2.5-Coder-3B-Instruct": "class Day11ChronalCharge() {\n    init {\n        super()\n    }\n}"}
{"kt_path": "n81ur3__kotlin-coding-challenges__fdc5941/src/main/kotlin/adventofcode2020/Day19MonsterMessage.kt", "Qwen2.5-Coder-3B-Instruct": "class Day19MonsterMessage"}
{"kt_path": "n81ur3__kotlin-coding-challenges__fdc5941/src/main/kotlin/adventofcode2017/Day07RecursiveCircus.kt", "Qwen2.5-Coder-3B-Instruct": "class Day07RecursiveCircus"}
{"kt_path": "n81ur3__kotlin-coding-challenges__fdc5941/src/main/kotlin/adventofcode2019/Day12TheNbodyProblem.kt", "Qwen2.5-Coder-3B-Instruct": "class Day12TheNbodyProblem"}
{"kt_path": "n81ur3__kotlin-coding-challenges__fdc5941/src/main/kotlin/adventofcode2018/Day15BeverageBandits.kt", "Qwen2.5-Coder-3B-Instruct": "class BeverageBandits"}
{"kt_path": "n81ur3__kotlin-coding-challenges__fdc5941/src/main/kotlin/adventofcode2020/Day07HandyHaversacks.kt", "Qwen2.5-Coder-3B-Instruct": "class Day07HandyHaversacks"}
{"kt_path": "n81ur3__kotlin-coding-challenges__fdc5941/src/main/kotlin/adventofcode2018/Day07TheSumOfItsParts.kt", "Qwen2.5-Coder-3B-Instruct": "class Day07TheSumOfItsParts {\n    constructor()\n}"}
{"kt_path": "n81ur3__kotlin-coding-challenges__fdc5941/src/main/kotlin/adventofcode2017/Day25TheHaltingProblem.kt", "Qwen2.5-Coder-3B-Instruct": "class Day25TheHaltingProblem {\n    constructor()\n}"}
{"kt_path": "n81ur3__kotlin-coding-challenges__fdc5941/src/main/kotlin/adventofcode2019/Day06UniversalOrbitMap.kt", "Qwen2.5-Coder-3B-Instruct": "class Day06UniversalOrbitMap() {\n}"}
{"kt_path": "n81ur3__kotlin-coding-challenges__fdc5941/src/main/kotlin/adventofcode2019/Day10MonitoringStation.kt", "Qwen2.5-Coder-3B-Instruct": "class Day10MonitoringStation {\n    constructor()\n}"}
{"kt_path": "n81ur3__kotlin-coding-challenges__fdc5941/src/main/kotlin/adventofcode2018/Day06ChronalCoordinates.kt", "Qwen2.5-Coder-3B-Instruct": "class Day06ChronalCoordinates() {\n    constructor()\n}"}
{"kt_path": "n81ur3__kotlin-coding-challenges__fdc5941/src/main/kotlin/adventofcode2020/Day21AllergenAssessment.kt", "Qwen2.5-Coder-3B-Instruct": "class Day21AllergenAssessment {\n    constructor()\n}"}
{"kt_path": "n81ur3__kotlin-coding-challenges__fdc5941/src/main/kotlin/adventofcode2017/Day24ElectromagneticMoat.kt", "Qwen2.5-Coder-3B-Instruct": "class Day24ElectromagneticMoat"}
{"kt_path": "n81ur3__kotlin-coding-challenges__fdc5941/src/main/kotlin/adventofcode2018/Day12SubterraneanSustainability.kt", "Qwen2.5-Coder-3B-Instruct": "class Day12SubterraneanSustainability"}
{"kt_path": "n81ur3__kotlin-coding-challenges__fdc5941/src/main/kotlin/adventofcode2018/Day23ExperimentalEmergencyTeleportation.kt", "Qwen2.5-Coder-3B-Instruct": "class Day23ExperimentalEmergencyTeleportation"}
{"kt_path": "alebedev__aoc2022__d6ba46b/src/main/kotlin/Map.kt", "Qwen2.5-Coder-3B-Instruct": "class MapKt {\n    companion object {\n        @JvmStatic fun main() {\n            AocMap.INSTANCE.solve()\n        }\n\n        @JvmStatic fun main(args: Array<String>) {\n            main()\n        }\n    }\n}"}
{"kt_path": "andrewrlee__adventOfCode2020__a9c21a6/src/main/kotlin/File09.kt", "Qwen2.5-Coder-3B-Instruct": "class Challenge09 {\n    fun solve() {\n        println(\"Hello, World!\")\n    }\n}\n\nfun main() {\n    Challenge09().solve()\n}"}
{"kt_path": "andrewrlee__adventOfCode2020__a9c21a6/src/main/kotlin/File08.kt", "Qwen2.5-Coder-3B-Instruct": "class Challenge08 {\n    fun solve() {\n        println(\"Hello, World!\")\n    }\n}\n\nfun main() {\n    Challenge08().solve()\n}"}
{"kt_path": "andrewrlee__adventOfCode2020__a9c21a6/src/main/kotlin/File02.kt", "Qwen2.5-Coder-3B-Instruct": "class Challenge02 {\n    fun solve() {\n        println(\"Hello, World!\")\n    }\n}\n\nfun main() {\n    Challenge02().solve()\n}"}
{"kt_path": "andrewrlee__adventOfCode2020__a9c21a6/src/main/kotlin/File07.kt", "Qwen2.5-Coder-3B-Instruct": "class Challenge07 {\n    fun solve() {\n        println(\"Hello, World!\")\n    }\n}\n\nfun main() {\n    Challenge07().solve()\n}"}
{"kt_path": "charlesfranciscodev__codingame__3ec8060/puzzles/kotlin/src/war/war.kt", "Qwen2.5-Coder-3B-Instruct": "fun main(args: Array<String>) {\n    val game = Game()\n    game.play()\n}"}
{"kt_path": "al-volkov__spbu_2020_kotlin_homeworks__5049681/src/main/kotlin/homework_5/Task1.kt", "Qwen2.5-Coder-3B-Instruct": "fun isNumber(s: String): Boolean {\n    return s.toIntOrNull() != null\n}"}
{"kt_path": "iafsilva__codility-lessons__5d86aef/src/main/kotlin/lesson3/FrogJmp.kt", "Qwen2.5-Coder-3B-Instruct": "class FrogJmp {\n    fun solution(x: Int, y: Int, k: Int): Int {\n        val distance = y - x\n        val jumps = distance / k\n        val remainder = distance % k\n        return if (remainder != 0) jumps + 1 else jumps\n    }\n}"}
{"kt_path": "mikhalchenko-alexander__advent-of-kotlin-2018-week1__c483ade/src/main/kotlin/com/anahoret/pathfinding/MarkingWayOnMap.kt", "Qwen2.5-Coder-3B-Instruct": "package com.anahoret.pathfinding\n\nimport kotlin.jvm.internal.Intrinsics.checkNotNullParameter\n\nobject MarkingWayOnMapKt {\n    fun addPath(map: String): String {\n        checkNotNullParameter(map, \"map\")\n        return Graph.INSTANCE.getMapWithPath(map)\n    }\n}"}
{"kt_path": "charlesfranciscodev__codingame__3ec8060/puzzles/kotlin/src/surface/surface.kt", "Qwen2.5-Coder-3B-Instruct": "class SurfaceKt {\n\n    companion object {\n        const val LAND = 'L'\n        const val WATER = 'W'\n        const val DEFAULT_INDEX = 0\n    }\n\n    @JvmStatic\n    fun main(args: Array<String>) {\n        val grid = Grid()\n        Intrinsics.checkNotNullParameter(args, \"args\")\n        grid.readGameInput()\n        grid.test()\n    }\n}\n\nclass Grid {\n    fun readGameInput() {\n        // Implementation for reading game input\n    }\n\n    fun test() {\n        // Implementation for testing the grid\n    }\n}"}
{"kt_path": "andrew-suprun__AoC-2023__dd5f53e/src/main/kotlin/day03_oop/day03_oop.kt", "Qwen2.5-Coder-3B-Instruct": "class Part1(val data: String) {\n    fun run() {\n        println(data)\n    }\n}\n\nclass Part2(val data: String) {\n    fun run() {\n        println(data)\n    }\n}\n\nfun main() {\n    Part1(\"input.data\").run()\n    Part2(\"input.data\").run()\n}"}
{"kt_path": "getnahid__programing-problem-solves-kotlin__589c392/CyclicRotation.kt", "Qwen2.5-Coder-3B-Instruct": "fun solution(arr: IntArray, k: Int): IntArray {\n    val n = arr.size\n    val result = IntArray(n)\n    for (i in 0 until n) {\n        result[(i + k) % n] = arr[i]\n    }\n    return result\n}"}
{"kt_path": "linisme__LeetCodeInKotlin__4382afc/LongestPalindrome.kt", "Qwen2.5-Coder-3B-Instruct": "class LongestPalindromeSolution {\n    fun longestPalindrome(s: String): String {\n        // Implementation of the longest palindrome logic goes here\n        return \"\"\n    }\n}\n\nfun main(args: Array<String>) {\n    val solution = LongestPalindromeSolution()\n    val result = solution.longestPalindrome(\"abbccbbdl\")\n    println(result)\n}"}
{"kt_path": "iafsilva__codility-lessons__5d86aef/src/main/kotlin/lesson2/OddOccurrencesInArray.kt", "Qwen2.5-Coder-3B-Instruct": "class OddOccurrencesInArray {\n    fun solution(a: IntArray): Int {\n        var result = 0\n        for (i in a.indices) {\n            result = result xor a[i]\n        }\n        return result\n    }\n}"}
{"kt_path": "jjeda__playground__5d1ee6c/src/oop/algorithm/ProgressionNextNumber.kt", "Qwen2.5-Coder-3B-Instruct": "package oop.algorithm\n\nimport kotlin.collections.ArraysKt.toList\nimport kotlin.jvm.internal.Intrinsics.checkNotNullParameter\n\nclass ProgressionNextNumber {\n    fun solution(numbers: IntArray): Int {\n        checkNotNullParameter(numbers, \"numbers\")\n        val progressionHelper = ProgressionHelper(numbers.toList())\n        return progressionHelper.nextInt()\n    }\n}\n\nclass ProgressionHelper(private val numbers: List<Int>) {\n    fun nextInt(): Int {\n        // Implement the logic to find the next number in the progression\n        // For example, you might assume a simple arithmetic progression\n        return numbers[0] + (numbers.size - 1) * (numbers[1] - numbers[0])\n    }\n}"}
{"kt_path": "linisme__LeetCodeInKotlin__4382afc/LengthOfLongestSubstring.kt", "Qwen2.5-Coder-3B-Instruct": "class LengthOfLongestSubstringSolution2 {\n    fun lengthOfLongestSubstring(s: String): Int {\n        val charSet = mutableSetOf<Char>()\n        var left = 0\n        var maxLength = 0\n\n        for (right in s.indices) {\n            while (charSet.contains(s[right])) {\n                charSet.remove(s[left])\n                left++\n            }\n            charSet.add(s[right])\n            maxLength = maxOf(maxLength, right - left + 1)\n        }\n\n        return maxLength\n    }\n}\n\nfun main(args: Array<String>) {\n    val solution = LengthOfLongestSubstringSolution2()\n    val result = solution.lengthOfLongestSubstring(\"abba\")\n    println(result)\n}"}
{"kt_path": "nschulzke__mancala-puzzle-solver__b130d3b/src/main/kotlin/Main.kt", "Qwen2.5-Coder-3B-Instruct": "package com.nschulzke\n\nimport java.util.*\n\nobject MainKt {\n    private val mancalaIndices: Set<Int> = setOf(6, 13)\n\n    companion object {\n        fun access$getMancalaIndices$p(): Set<Int> {\n            return mancalaIndices\n        }\n    }\n}"}
{"kt_path": "sysion__DataStructureAlgorithmKt__6f9afda/TwoSumLessThanTarget.kt", "Qwen2.5-Coder-3B-Instruct": "fun main() {\n    val intArray = arrayOf(10, 20, 30)\n    val target = 15\n    println(SumTwoNumbersLessThanTarget(intArray, target))\n}\n\nfun SumTwoNumbersLessThanTarget(intArray: IntArray, target: Int): Int {\n    var count = 0\n    for (i in intArray.indices) {\n        for (j in i + 1 until intArray.size) {\n            if (intArray[i] + intArray[j] < target) {\n                count++\n            }\n        }\n    }\n    return count\n}"}
{"kt_path": "linisme__LeetCodeInKotlin__4382afc/FineMedianSortedArrays.kt", "Qwen2.5-Coder-3B-Instruct": "import kotlin.math.*\n\nclass FindMedianSortedArraysSolution {\n    fun findMedianSortedArrays(nums1: IntArray, nums2: IntArray): Double {\n        val merged = merge(nums1, nums2)\n        val mid = merged.size / 2\n        return if (merged.size % 2 == 0) {\n            (merged[mid - 1] + merged[mid]) / 2.0\n        } else {\n            merged[mid]\n        }\n    }\n\n    private fun merge(nums1: IntArray, nums2: IntArray): IntArray {\n        val result = IntArray(nums1.size + nums2.size)\n        var i = 0\n        var j = 0\n        var k = 0\n\n        while (i < nums1.size && j < nums2.size) {\n            if (nums1[i] < nums2[j]) {\n                result[k++] = nums1[i++]\n            } else {\n                result[k++] = nums2[j++]\n            }\n        }\n\n        while (i < nums1.size) {\n            result[k++] = nums1[i++]\n        }\n\n        while (j < nums2.size) {\n            result[k++] = nums2[j++]\n        }\n\n        return result\n    }\n}\n\nfun main(args: Array<String>) {\n    val solution = FindMedianSortedArraysSolution()\n    val nums1 = intArrayOf(1, 3)\n    val nums2 = intArrayOf(2)\n    println(solution.findMedianSortedArrays(nums1, nums2))\n}"}
{"kt_path": "n81ur3__kotlin-coding-challenges__fdc5941/src/main/kotlin/adventofcode2018/Day18SettlersOfTheNorthPole.kt", "Qwen2.5-Coder-3B-Instruct": "package adventofcode2018\n\nfun hash(list: List<List<AreaElement>>): Int {\n    require(list != null) { \"<this>\" }\n    return list.toList().let { Arrays.deepHashCode(it) }\n}\n\nclass Day18SettlersOfTheNorthPole"}
{"kt_path": "iafsilva__codility-lessons__5d86aef/src/main/kotlin/lesson3/PermMissingElem.kt", "Qwen2.5-Coder-3B-Instruct": "class PermMissingElem {\n    fun solution(arr: IntArray): Int {\n        val n = arr.size\n        if (n == 0) return 1\n\n        arr.sort()\n\n        for (i in 0 until n - 1) {\n            if (arr[i] + 1 != arr[i + 1]) {\n                return arr[i] + 1\n            }\n        }\n\n        return arr[n - 1] + 1\n    }\n}"}
{"kt_path": "getnahid__programing-problem-solves-kotlin__589c392/OddOccurrencesInArray.kt", "Qwen2.5-Coder-3B-Instruct": "fun solution(arr: IntArray): Int {\n    arr.sort()\n    val length = arr.size\n    var i = 0\n    var j = length - 1\n\n    while (i < j) {\n        if (arr[i] != arr[j]) {\n            return arr[i]\n        }\n        i++\n        j--\n    }\n\n    return arr[i]\n}"}
{"kt_path": "rupeshsasne__coursera-algorithms-part1__341634c/classroom/src/main/kotlin/com/radix2/algorithms/week3/SortingLinkedList.kt", "Qwen2.5-Coder-3B-Instruct": "import java.util.*\n\nclass LinkedList<T : Comparable<T>> {\n    private var head: Node<T>? = null\n\n    fun add(element: T) {\n        val newNode = Node(element)\n        if (head == null) {\n            head = newNode\n        } else {\n            var current = head\n            while (current?.next != null) {\n                current = current.next\n            }\n            current?.next = newNode\n        }\n    }\n\n    fun reverseRecurrsive(): LinkedList<T> {\n        var current = head\n        head = null\n        reverseRecurrsiveHelper(current)\n        return this\n    }\n\n    private fun reverseRecurrsiveHelper(node: Node<T>?) {\n        if (node == null) {\n            return\n        }\n        reverseRecurrsiveHelper(node.next)\n        node.next = head\n        head = node\n    }\n\n    override fun toString(): String {\n        val elements = mutableListOf<T>()\n        var current = head\n        while (current != null) {\n            elements.add(current.value)\n            current = current.next\n        }\n        return elements.joinToString(\", \")\n    }\n\n    private inner class Node<T>(val value: T, var next: Node<T>? = null)\n}\n\nfun main(args: Array<String>) {\n    val list = LinkedList<Int>()\n    for (i in 0..10) {\n        list.add(i)\n    }\n    list.reverseRecurrsive()\n    println(list)\n}"}
{"kt_path": "boris920308__HoOne__8881468/hoon/HoonAlgorithm/src/main/kotlin/boj/week02/recursive_function/FibonacciSequence5.kt", "Qwen2.5-Coder-3B-Instruct": "import java.util.Scanner\n\nfun main() {\n    val scanner = Scanner(System.`in`)\n    val n = scanner.nextInt()\n    println(fibonacci(n))\n}\n\nfun fibonacci(n: Int): Int {\n    if (n <= 1) {\n        return n\n    }\n    return fibonacci(n - 1) + fibonacci(n - 2)\n}"}
{"kt_path": "Codextor__kotlin-codes__68b75a7/src/main/kotlin/PerfectSquares.kt", "Qwen2.5-Coder-3B-Instruct": "fun numSquares(n: Int): Int {\n    val squares = IntArray(n + 1)\n    squares[0] = 0\n\n    for (i in 1..n) {\n        squares[i] = Int.MAX_VALUE\n        for (j in 1..Math.sqrt(i.toDouble()).toInt()) {\n            squares[i] = minOf(squares[i], squares[i - j * j] + 1)\n        }\n    }\n\n    return squares[n]\n}"}
{"kt_path": "Laomedeia__Java8InAction__0dcd843/src/main/java/leetcode/a167_twoSumInputSortArray_SIMPLE/Solution.kt", "Qwen2.5-Coder-3B-Instruct": "class Solution {\n    fun twoSum(numbers: IntArray, target: Int): IntArray {\n        val n = numbers.size\n        var left = 0\n        var right = n - 1\n        \n        while (left < right) {\n            val sum = numbers[left] + numbers[right]\n            when {\n                sum == target -> return intArrayOf(left, right)\n                sum < target -> left++\n                else -> right--\n            }\n        }\n        \n        return intArrayOf()\n    }\n}"}
{"kt_path": "ariannysOronoz__tutorialKotlin__a779f54/CombinacionesPalabras/src/main/java/Main.kt", "Qwen2.5-Coder-3B-Instruct": "package com.includehelp.basic\n\nfun main(args: Array<String>) {\n    val permutation = Permutation()\n    val caracol = \"CARACOL\"\n    val length = caracol.length\n    permutation.findPermutation(caracol, 0, length)\n    println()\n\n    val caracol2 = \"caracol\"\n    val length2 = caracol2.length\n    permutation.findPermutation(caracol2, 0, length2)\n}\n\nclass Permutation {\n    fun findPermutation(s: String, start: Int, end: Int) {\n        if (start == end) {\n            println(s)\n            return\n        }\n        for (i in start until end) {\n            s = swap(s, start, i)\n            findPermutation(s, start + 1, end)\n            s = swap(s, start, i) // backtrack\n        }\n    }\n\n    private fun swap(s: String, i: Int, j: Int): String {\n        val chars = s.toCharArray()\n        val temp = chars[i]\n        chars[i] = chars[j]\n        chars[j] = temp\n        return String(chars)\n    }\n}"}
{"kt_path": "scientificCommunity__blog-sample__36e291c/algorithms/src/main/kotlin/org/baichuan/sample/algorithms/leetcode/middle/MaxArea.kt", "Qwen2.5-Coder-3B-Instruct": "class MaxArea {\n    fun maxArea(height: IntArray): Int {\n        var left = 0\n        var right = height.size - 1\n        var maxArea = 0\n\n        while (left < right) {\n            val currentArea = Math.min(height[left], height[right]) * (right - left)\n            maxArea = Math.max(maxArea, currentArea)\n\n            if (height[left] < height[right]) {\n                left++\n            } else {\n                right--\n            }\n        }\n\n        return maxArea\n    }\n}"}
{"kt_path": "boris920308__HoOne__8881468/hoon/HoonAlgorithm/src/main/kotlin/programmers/lv01/Lv1_70128.kt", "Qwen2.5-Coder-3B-Instruct": "fun main() {\n    val arr1 = intArrayOf(1, 2, 3, 4)\n    val arr2 = intArrayOf(-3, -1, 0, 2)\n    println(solution(arr1, arr2))\n}\n\nprivate fun solution(arr1: IntArray, arr2: IntArray): Int {\n    var result = 0\n    for (i in arr1.indices) {\n        result += arr1[i] * arr2[i]\n    }\n    return result\n}"}
{"kt_path": "kotler-dev__kotlin-leetcode__0659e72/src/main/kotlin/exercise/easy/id121/Solution121.kt", "Qwen2.5-Coder-3B-Instruct": "class Solution121 {\n    fun maxProfit(prices: IntArray): Int {\n        val n = prices.size\n        if (n < 2) return 0\n\n        var minPrice = Int.MAX_VALUE\n        var maxProfit = 0\n\n        for (i in 0 until n) {\n            if (prices[i] < minPrice) {\n                minPrice = prices[i]\n            } else {\n                maxProfit = Math.max(maxProfit, prices[i] - minPrice)\n            }\n        }\n\n        return maxProfit\n    }\n}"}
{"kt_path": "marc-bouvier-katas__Kotlin_EduTools_Advent_of_Code_2021__12cf74c/Day 5/Part 1/src/Task.kt", "Qwen2.5-Coder-3B-Instruct": "import kotlin.jvm.internal.Intrinsics.checkNotNullParameter\n\nclass TaskKt {\n    companion object {\n        fun overlaps(lines: Array<String>): Int {\n            checkNotNullParameter(lines, \"lines\")\n            val linesMap = mutableMapOf<String, Line>()\n            var lineCount = lines.size\n            var overlapCount = 0\n\n            for (i in 0 until lineCount) {\n                val line = lines[i]\n                val lineOfVent = LineOfVent.fromString(line)\n                val lineObj = Line.fromLineOfVent(lineOfVent)\n                linesMap[line] = lineObj\n                overlapCount += lineObj.overlaps()\n            }\n\n            return overlapCount\n        }\n    }\n}\n\ndata class Line(val lineOfVent: LineOfVent, val overlaps: Int)\n\ndata class LineOfVent(val ventLines: List<String>)\n\nfun LineOfVent.fromString(ventLines: String): LineOfVent {\n    // Implementation of fromString method\n    return LineOfVent(ventLines.split(\",\"))\n}\n\nfun Line.fromLineOfVent(lineOfVent: LineOfVent): Line {\n    // Implementation of fromLineOfVent method\n    return Line(lineOfVent, 0) // Placeholder implementation\n}\n\nfun Line.mergeWith(other: Line) {\n    // Implementation of mergeWith method\n}"}
{"kt_path": "Laomedeia__Java8InAction__0dcd843/src/main/java/leetcode/a392_isSubSequence_HARD/Solution.kt", "Qwen2.5-Coder-3B-Instruct": "class Solution {\n    fun isSubsequence(s: String, t: String): Boolean {\n        if (s.isEmpty()) return true\n        var i = 0\n        for (c in t) {\n            if (i < s.length && c == s[i]) i++\n        }\n        return i == s.length\n    }\n}"}
{"kt_path": "nickperov__Algorithms__6696f5d/fibonacci/src/main/kotlin/com/nickperov/stud/algorithms/fibonacci/FibonacciLargeGenerator.kt", "Qwen2.5-Coder-3B-Instruct": "package com.nickperov.stud.algorithms.fibonacci\n\nimport java.math.BigInteger\n\nclass FibonacciLargeTailRecursiveOptimisedGenerator : FibonacciLargeGenerator() {\n    override fun calculate(n: Int): BigInteger {\n        if (n <= 1) return BigInteger.valueOf(n)\n        var a = BigInteger.ZERO\n        var b = BigInteger.ONE\n        for (i in 2..n) {\n            val temp = a + b\n            a = b\n            b = temp\n        }\n        return b\n    }\n}\n\nfun main() {\n    println(\"Hello, large Fibonacci numbers\")\n    val generator = FibonacciLargeTailRecursiveOptimisedGenerator()\n    println(generator.calculate(1000000))\n}"}
{"kt_path": "TonnyL__Windary__39f85cd/Kotlin/src/UniqueBinarySearchTrees.kt", "Qwen2.5-Coder-3B-Instruct": "class UniqueBinarySearchTrees {\n    fun numTrees(n: Int): Int {\n        val dp = IntArray(n + 1)\n        dp[0] = 1\n        for (i in 1..n) {\n            for (j in 0 until i) {\n                dp[i] += dp[j] * dp[i - j - 1]\n            }\n        }\n        return dp[n]\n    }\n}"}
{"kt_path": "quincy__euler-kotlin__01d96f6/src/main/kotlin/com/quakbo/euler/Euler4.kt", "Qwen2.5-Coder-3B-Instruct": "class Euler4Kt {\n\n    companion object {\n        fun isPalindrome(num: Int): Boolean {\n            val str = num.toString()\n            val reversedStr = str.reversed()\n            return str == reversedStr\n        }\n\n        @JvmStatic\n        fun main(args: Array<String>) {\n            for (i in 899 downTo 100) {\n                for (j in 899 downTo 100) {\n                    val product = i * j\n                    if (isPalindrome(product)) {\n                        println(product)\n                    }\n                }\n            }\n        }\n    }\n}"}
{"kt_path": "getupminaaa__Algorithm__01187e2/Algorithm/src/main/kotlin/programmers/level1/personalInfoCollectionValidityPeriod.kt", "Qwen2.5-Coder-3B-Instruct": "class Solution {\n    fun solution(date: String, validityPeriods: Array<String>): Int {\n        val dateParts = date.split(\".\")\n        val year = dateParts[0].toInt()\n        val month = dateParts[1].toInt()\n        val day = dateParts[2].toInt()\n\n        val validityPeriodsArray = validityPeriods.map { it.split(\".\") }\n        val validDays = mutableListOf<Int>()\n\n        for (period in validityPeriodsArray) {\n            val startYear = period[0].toInt()\n            val startMonth = period[1].toInt()\n            val startDate = period[2].toInt()\n            val endYear = period[3].toInt()\n            val endMonth = period[4].toInt()\n            val endDate = period[5].toInt()\n\n            if (year >= startYear && year <= endYear) {\n                if (year == startYear && month < startMonth) {\n                    continue\n                }\n                if (year == endYear && month > endMonth) {\n                    continue\n                }\n                if (year == startYear && month == startMonth && day < startDate) {\n                    continue\n                }\n                if (year == endYear && month == endMonth && day > endDate) {\n                    continue\n                }\n                validDays.add(day)\n            }\n        }\n\n        return validDays.size\n    }\n}\n\nfun main() {\n    val solution = Solution()\n    val result = solution.solution(\"2022.05.19\", arrayOf(\"2021.05.02 A\", \"2021.07.01 B\", \"2022.02.19 C\", \"2022.02.20 C\"))\n    println(result) // Output: 1\n}"}
{"kt_path": "iafsilva__codility-lessons__5d86aef/src/main/kotlin/lesson1/BinaryGap.kt", "Qwen2.5-Coder-3B-Instruct": "class BinaryGap {\n    fun solution(n: Int): Int {\n        var maxGap = 0\n        var currentGap = 0\n        var hasOne = false\n\n        val binaryString = n.toString(2)\n\n        for (i in binaryString.indices) {\n            if (binaryString[i] == '1') {\n                if (hasOne) {\n                    maxGap = maxOf(maxGap, currentGap)\n                    currentGap = 0\n                }\n                hasOne = true\n            } else {\n                currentGap++\n            }\n        }\n\n        return maxGap\n    }\n}"}
{"kt_path": "zys0909__CodeLabs__869c7c2/src/com/leecode/array/Code1.kt", "Qwen2.5-Coder-3B-Instruct": "package com.leecode.array\n\nfun missingNumber1(nums: IntArray): Int {\n    val n = nums.size\n    var sum = 0\n    for (i in nums) {\n        sum += i\n    }\n    return n * (n + 1) / 2 - sum\n}\n\nfun missingNumber2(nums: IntArray): Int {\n    val n = nums.size\n    var left = 0\n    var right = n - 1\n    while (left < right) {\n        val mid = left + (right - left) / 2\n        if (nums[mid] == mid) {\n            left = mid + 1\n        } else {\n            right = mid\n        }\n    }\n    return left\n}"}
{"kt_path": "ykrytsyn__leetcode-in-kotlin__0acf2a6/src/main/kotlin/leetcode/ArrangingCoins.kt", "Qwen2.5-Coder-3B-Instruct": "class ArrangingCoins {\n    fun bruteForce(n: Int): Int {\n        var k = n\n        while (k > 0) {\n            k -= 1\n        }\n        return k\n    }\n\n    fun binarySearch(n: Int): Int {\n        var left = 0L\n        var right = n.toLong()\n        while (left <= right) {\n            val mid = (left + right) / 2\n            val coins = mid * (mid + 1) / 2\n            if (coins == n.toLong()) {\n                return mid.toInt()\n            } else if (coins < n.toLong()) {\n                left = mid + 1\n            } else {\n                right = mid - 1\n            }\n        }\n        return left.toInt() - 1\n    }\n}"}
{"kt_path": "mayabot__mynlp__b980da3/mynlp/src/main/java/com/mayabot/nlp/module/nwd/ValueObjects.kt", "Qwen2.5-Coder-3B-Instruct": "import java.util.*\n\nclass IntCount(var value: Int = 0)\n\nfun addTo(map: HashMap<Char, IntCount>, key: Char, value: Int) {\n    val count = map.getOrPut(key) { IntCount() }\n    count.value += value\n}"}
{"kt_path": "jjrodcast__CompetitiveProblems__a91868c/leetcode/UniquePathsTwo.kt", "Qwen2.5-Coder-3B-Instruct": "class Solution {\n    fun uniquePathsWithObstacles(obstacleGrid: Array<IntArray>): Int {\n        val m = obstacleGrid.size\n        val n = obstacleGrid[0].size\n        val dp = Array(m + 1) { IntArray(n + 1) }\n\n        for (i in 1..m) {\n            for (j in 1..n) {\n                if (obstacleGrid[i - 1][j - 1] == 1) {\n                    dp[i][j] = 0\n                } else {\n                    dp[i][j] = dp[i - 1][j] + dp[i][j - 1]\n                }\n            }\n        }\n\n        return dp[m][n]\n    }\n}\n\nfun main() {\n    val solution = Solution()\n    val obstacleGrid = arrayOf(\n        intArrayOf(0, 0, 0),\n        intArrayOf(0, 1, 0),\n        intArrayOf(0, 0, 0)\n    )\n    println(solution.uniquePathsWithObstacles(obstacleGrid))\n}"}
{"kt_path": "boris920308__HoOne__8881468/hoon/HoonAlgorithm/src/main/kotlin/programmers/lv01/Lv1_77884.kt", "Qwen2.5-Coder-3B-Instruct": "fun main() {\n    println(solution(13, 17))\n}\n\nprivate fun solution(a: Int, b: Int): Int {\n    var result = 0\n    for (i in a..b) {\n        if (countDivisors(i) % 2 == 0) {\n            result += i\n        }\n    }\n    return result\n}\n\nprivate fun countDivisors(n: Int): Int {\n    var count = 0\n    val sqrt = Math.sqrt(n.toDouble()).toInt()\n    for (i in 1..sqrt) {\n        if (n % i == 0) {\n            count += 2\n            if (i * i == n) {\n                count -= 1\n            }\n        }\n    }\n    return count\n}"}
{"kt_path": "Codextor__kotlin-codes__68b75a7/src/main/kotlin/PartitionArrayForMaximumSum.kt", "Qwen2.5-Coder-3B-Instruct": "fun maxSumAfterPartitioning(arr: IntArray, k: Int): Int {\n    val n = arr.size\n    val dp = Array(n + 1) { IntArray(k + 1) }\n    \n    for (i in 1..n) {\n        var maxVal = 0\n        for (j in 1..k) {\n            maxVal = Math.max(maxVal, arr[i - 1])\n            dp[i][j] = Math.max(dp[i][j], dp[i - j][j] + maxVal * j)\n        }\n    }\n    \n    return dp[n][k]\n}"}
{"kt_path": "scientificCommunity__blog-sample__36e291c/algorithms/src/main/kotlin/org/baichuan/sample/algorithms/leetcode/simple/interview/MajorityElement.kt", "Qwen2.5-Coder-3B-Instruct": "class MajorityElement {\n    fun majorityElement(nums: IntArray): Int {\n        val n = nums.size\n        var count = 0\n        var candidate = 0\n\n        for (num in nums) {\n            if (count == 0) {\n                candidate = num\n            }\n            if (num == candidate) {\n                count++\n            } else {\n                count--\n            }\n        }\n\n        return candidate\n    }\n}"}
{"kt_path": "rhavran__ProjectEuler__1115674/src/Utils.kt", "Qwen2.5-Coder-3B-Instruct": "class PrimeFactorization {\n    companion object {\n        val INSTANCE = PrimeFactorization()\n\n        fun primeFactors(n: Long): Map<Long, Long> {\n            // Implementation of primeFactors method\n            return mapOf()\n        }\n    }\n}\n\nfun dividers(n: Long): Long {\n    val map = PrimeFactorization.INSTANCE.primeFactors(n)\n    var result = 1L\n    for ((_, value) in map.entries) {\n        result *= value\n    }\n    return result\n}\n\nfun sequenceSumStartingFrom(start: Long, end: Long): Long {\n    return sumFromTo(end, start)\n}\n\nfun sumFromTo(start: Long, end: Long): Long {\n    return (end - start + 1) * (start + end) / 2\n}"}
{"kt_path": "jimmymorales__project-euler__e881cad/src/main/kotlin/Problem4.kt", "Qwen2.5-Coder-3B-Instruct": "fun largestPalindrome(): Int {\n    var largest = 0\n    for (i in 100..999) {\n        for (j in 100..999) {\n            val product = i * j\n            if (isPalindrome(product)) {\n                largest = maxOf(largest, product)\n            }\n        }\n    }\n    return largest\n}\n\nfun isPalindrome(num: Int): Boolean {\n    val reversed = reverse(num)\n    return num == reversed\n}\n\nfun reverse(num: Int): Int {\n    var reversed = 0\n    var original = num\n    while (original > 0) {\n        reversed = reversed * 10 + original % 10\n        original /= 10\n    }\n    return reversed\n}\n\nfun main(args: Array<String>) {\n    println(largestPalindrome())\n}"}
{"kt_path": "Codextor__kotlin-codes__68b75a7/src/main/kotlin/PalindromicSubstrings.kt", "Qwen2.5-Coder-3B-Instruct": "class PalindromicSubstringsKt {\n\n    companion object {\n        fun countSubstrings(s: String): Int {\n            requireNotNull(s) { \"s must not be null\" }\n            var count = 0\n            for (i in 0 until s.length) {\n                count += countSubstringsWithCenter(s, i, i)\n                count += countSubstringsWithCenter(s, i, i + 1)\n            }\n            return count\n        }\n\n        private fun countSubstringsWithCenter(s: String, left: Int, right: Int): Int {\n            var count = 0\n            while (left >= 0 && right < s.length && s[left] == s[right]) {\n                count++\n                left--\n                right++\n            }\n            return count\n        }\n    }\n}"}
{"kt_path": "antop-dev__algorithm__9a3e762/src/main/kotlin/kr/co/programmers/P12952.kt", "Qwen2.5-Coder-3B-Instruct": "class P12952 {\n    fun solution(n: Int): Int {\n        val visited = Array(n) { BooleanArray(n) }\n        return dfs(visited, n)\n    }\n\n    private fun dfs(visited: Array<BooleanArray>, n: Int, row: Int = 0, col: Int = 0): Int {\n        if (row == n) return 1\n        if (col == n) return dfs(visited, n, row + 1, 0)\n\n        var count = 0\n        for (i in 0 until n) {\n            if (!visited[row][i]) {\n                visited[row][i] = true\n                if (valid(visited, n, row, i)) {\n                    count += dfs(visited, n, row, i)\n                }\n                visited[row][i] = false\n            }\n        }\n        return count\n    }\n\n    private fun valid(visited: Array<BooleanArray>, n: Int, row: Int, col: Int): Boolean {\n        for (i in 0 until n) {\n            if (visited[row][i]) return false\n            if (visited[i][col]) return false\n        }\n        for (i in 0 until n) {\n            for (j in 0 until n) {\n                if (visited[i][j] && abs(row - i) == abs(col - j)) return false\n            }\n        }\n        return true\n    }\n\n    companion object {\n        fun abs(x: Int): Int {\n            return if (x < 0) -x else x\n        }\n    }\n}"}
{"kt_path": "ILIYANGERMANOV__algorithms__4abe4b5/Algorithms/src/main/kotlin/MaxSubArray.kt", "Qwen2.5-Coder-3B-Instruct": "class MaxSubArray {\n    fun maxSubArray(nums: IntArray): Int {\n        val n = nums.size\n        if (n == 0) return 0\n        var maxSoFar = nums[0]\n        var maxEndingHere = nums[0]\n\n        for (i in 1 until n) {\n            maxEndingHere = maxOf(nums[i], maxEndingHere + nums[i])\n            maxSoFar = maxOf(maxSoFar, maxEndingHere)\n        }\n\n        return maxSoFar\n    }\n}"}
{"kt_path": "AlBovo__Compiti__56a3131/src/main/kotlin/segtree.kt", "Qwen2.5-Coder-3B-Instruct": "class SegmentTree(private val nums: IntArray) {\n    fun getSum(left: Int, right: Int): Int {\n        return getSumHelper(nums, left, right, 0, nums.size - 1)\n    }\n\n    private fun getSumHelper(nums: IntArray, left: Int, right: Int, start: Int, end: Int): Int {\n        if (left > end || right < start) return 0\n        if (left <= start && right >= end) return nums[start]\n        val mid = (start + end) / 2\n        return getSumHelper(nums, left, right, start, mid) + getSumHelper(nums, left, right, mid + 1, end)\n    }\n}\n\nfun main() {\n    val nums = intArrayOf(2, 3, 5, 7, 11, 13)\n    val segmentTree = SegmentTree(nums)\n    println(segmentTree.getSum(0, 4)) // Output: 20\n}"}
{"kt_path": "3mtee__exercism-kotlin__6e3eb88/complex-numbers/src/main/kotlin/ComplexNumbers.kt", "Qwen2.5-Coder-3B-Instruct": "import kotlin.math.*\n\nclass ComplexNumber(val real: Double, val imag: Double) {\n    companion object {\n        fun exponential(z: ComplexNumber): ComplexNumber {\n            val c = \"c\"\n            requireNotNull(z, { \"Complex number $c must not be null\" })\n\n            val realPart = z.real\n            val imagPart = z.imag\n\n            if (realPart == 0.0) {\n                return if (imagPart > 0.0) {\n                    ComplexNumber(1.0, imagPart)\n                } else {\n                    ComplexNumber(1.0, -imagPart)\n                }\n            }\n\n            val cosValue = cos(imagPart)\n            val sinValue = sin(imagPart)\n\n            return ComplexNumber(realPart * cosValue, realPart * sinValue)\n\n            val expValue = pow(2.718281828459045, realPart)\n            return ComplexNumber(expValue * cosValue, expValue * sinValue)\n        }\n    }\n}"}
{"kt_path": "perihanmirkelam__ProjectEuler__a24ac44/src/main/kotlin/P014_LongestCollatzSequence.kt", "Qwen2.5-Coder-3B-Instruct": "fun p14() {\n    var longestSequenceLength = 0\n    var numberWithLongestSequence = 0\n\n    for (i in 1..1_000_000) {\n        var currentNumber = i\n        var sequenceLength = 1\n\n        while (currentNumber != 1) {\n            if (currentNumber % 2 == 0) {\n                currentNumber /= 2\n            } else {\n                currentNumber = 3 * currentNumber + 1\n            }\n            sequenceLength++\n        }\n\n        if (sequenceLength > longestSequenceLength) {\n            longestSequenceLength = sequenceLength\n            numberWithLongestSequence = i\n        }\n    }\n\n    println(\"A14: $numberWithLongestSequence\")\n}"}
{"kt_path": "iafsilva__codility-lessons__5d86aef/src/main/kotlin/lesson2/CyclicRotation.kt", "Qwen2.5-Coder-3B-Instruct": "class CyclicRotation {\n\n    fun solution(a: IntArray, k: Int): IntArray {\n        val n = a.size\n        if (n == 0 || k % n == 0) return a\n\n        val deque = ArrayDeque<Int>()\n        for (num in a) {\n            deque.add(num)\n        }\n\n        while (k > 0) {\n            val last = deque.removeLast()\n            deque.addFirst(last)\n            k--\n        }\n\n        return Array(n) { deque[it] }\n    }\n}"}
{"kt_path": "boris920308__HoOne__8881468/hoon/HoonAlgorithm/src/main/kotlin/programmers/lv01/Lv1_12912.kt", "Qwen2.5-Coder-3B-Instruct": "fun main() {\n    println(solution(3, 5))\n    println(solution(3, 3))\n    println(solution(5, 3))\n}\n\nprivate fun solution(a: Int, b: Int): Long {\n    var result = 0L\n    for (i in a..b) {\n        result += i.toLong()\n    }\n    return result\n}\n\nprivate fun secondSolution(a: Int, b: Int): Long {\n    val range = if (a <= b) a..b else b..a\n    return range.sumOf { it.toLong() }\n}"}
{"kt_path": "darian-catalin-cucer__divide-and-conquer-algorithms__1cea70d/kt.kt", "Qwen2.5-Coder-3B-Instruct": "import kotlin.jvm.internal.Intrinsics.checkNotNullParameter\n\nfun quickSort(arr: IntArray, left: Int, right: Int) {\n    checkNotNullParameter(arr, \"arr\")\n    if (left >= right) return\n\n    val pivotIndex = partition(arr, left, right)\n    quickSort(arr, left, pivotIndex - 1)\n    quickSort(arr, pivotIndex + 1, right)\n}\n\nfun partition(arr: IntArray, left: Int, right: Int): Int {\n    checkNotNullParameter(arr, \"arr\")\n    val pivot = arr[right]\n    var i = left - 1\n\n    for (j in left..right - 1) {\n        if (arr[j] < pivot) {\n            i++\n            arr[i] = arr[j]\n            arr[j] = arr[i]\n        }\n    }\n\n    arr[i + 1] = arr[right]\n    arr[right] = arr[i + 1]\n    return i + 1\n}"}
{"kt_path": "TonnyL__Windary__39f85cd/Kotlin/src/ThreeSumClosest.kt", "Qwen2.5-Coder-3B-Instruct": "class ThreeSumClosest {\n    fun threeSumClosest(nums: IntArray, target: Int): Int {\n        nums.sort()\n        var closest = nums[0] + nums[1] + nums[2]\n        for (i in 0 until nums.size - 2) {\n            var left = i + 1\n            var right = nums.size - 1\n            while (left < right) {\n                val sum = nums[i] + nums[left] + nums[right]\n                if (Math.abs(sum - target) < Math.abs(closest - target)) {\n                    closest = sum\n                }\n                if (sum == target) {\n                    return target\n                } else if (sum < target) {\n                    left++\n                } else {\n                    right--\n                }\n            }\n        }\n        return closest\n    }\n}"}
{"kt_path": "Javran__leetcode__f3899fe/bulb-switcher/Solution.kt", "Qwen2.5-Coder-3B-Instruct": "class Solution {\n    companion object {\n        fun bulbSwitch(n: Int): Int {\n            return Math.floor(Math.sqrt(n.toDouble())).toInt()\n        }\n    }\n\n    fun main(args: Array<String>) {\n        println(bulbSwitch(10))\n    }\n}"}
{"kt_path": "TonnyL__Windary__39f85cd/Kotlin/src/NextPermutation.kt", "Qwen2.5-Coder-3B-Instruct": "class NextPermutation {\n    fun nextPermutation(nums: IntArray) {\n        val n = nums.size\n        var i = n - 2\n        while (i >= 0 && nums[i] >= nums[i + 1]) {\n            i--\n        }\n        if (i >= 0) {\n            var j = n - 1\n            while (j > i && nums[j] <= nums[i]) {\n                j--\n            }\n            swap(nums, i, j)\n        }\n        reverse(nums, i + 1, n - 1)\n    }\n\n    private fun swap(nums: IntArray, i: Int, j: Int) {\n        val temp = nums[i]\n        nums[i] = nums[j]\n        nums[j] = temp\n    }\n\n    private fun reverse(nums: IntArray, start: Int, end: Int) {\n        var left = start\n        var right = end\n        while (left < right) {\n            swap(nums, left, right)\n            left++\n            right--\n        }\n    }\n}"}
{"kt_path": "boris920308__HoOne__8881468/hoon/HoonAlgorithm/src/main/kotlin/programmers/lv01/Lv1_12940.kt", "Qwen2.5-Coder-3B-Instruct": "fun main() {\n    val result1 = solution(3, 12)\n    println(result1)\n\n    val result2 = solution(2, 5)\n    println(result2)\n}\n\nprivate fun solution(a: Int, b: Int): IntArray {\n    val result = IntArray(2)\n    result[0] = gcd(a, b)\n    result[1] = lcm(a, b)\n    println(result.toList())\n    return result\n}\n\nprivate fun gcd(a: Int, b: Int): Int {\n    return if (b == 0) a else gcd(b, a % b)\n}\n\nprivate fun lcm(a: Int, b: Int): Int {\n    return a * b / gcd(a, b)\n}"}
{"kt_path": "JiangKlijna__leetcode-learning__65a1348/kt/001 Two Sum/TwoSum.kt", "Qwen2.5-Coder-3B-Instruct": "class TwoSum {\n    fun twoSum(numbers: IntArray, target: Int): IntArray {\n        val map = HashMap<Int, Int>()\n        for (i in numbers.indices) {\n            val complement = target - numbers[i]\n            if (map.containsKey(complement)) {\n                return intArrayOf(map[complement]!!, i)\n            }\n            map[numbers[i]] = i\n        }\n        throw IllegalArgumentException(\"No two sum solution\")\n    }\n}"}
{"kt_path": "rupeshsasne__coursera-algorithms-part1__341634c/classroom/src/main/kotlin/com/radix2/algorithms/week1/UnionFind.kt", "Qwen2.5-Coder-3B-Instruct": "import kotlin.jvm.internal.Intrinsics.checkNotNullParameter\n\nclass WeightedQuickUnionWithPathCompressionUF(val size: Int) {\n    private val parent = IntArray(size)\n    private val rank = IntArray(size)\n\n    init {\n        for (i in 0 until size) {\n            parent[i] = i\n            rank[i] = 1\n        }\n    }\n\n    fun find(x: Int): Int {\n        if (parent[x] != x) {\n            parent[x] = find(parent[x])\n        }\n        return parent[x]\n    }\n\n    fun union(x: Int, y: Int) {\n        val rootX = find(x)\n        val rootY = find(y)\n        if (rootX == rootY) {\n            return\n        }\n        if (rank[rootX] > rank[rootY]) {\n            parent[rootY] = rootX\n        } else if (rank[rootX] < rank[rootY]) {\n            parent[rootX] = rootY\n        } else {\n            parent[rootY] = rootX\n            rank[rootX]++\n        }\n    }\n}\n\nfun main(args: Array<String>) {\n    checkNotNullParameter(args, \"args\")\n    val uf = WeightedQuickUnionWithPathCompressionUF(10)\n    uf.union(4, 3)\n    uf.union(3, 8)\n    uf.union(6, 5)\n    uf.union(9, 4)\n    uf.union(2, 1)\n    uf.union(5, 0)\n    uf.union(7, 2)\n    uf.union(6, 1)\n    uf.union(7, 3)\n}"}
{"kt_path": "boris920308__HoOne__8881468/hoon/HoonAlgorithm/src/main/kotlin/programmers/lv01/Lv1_68935.kt", "Qwen2.5-Coder-3B-Instruct": "fun main() {\n    println(solution(45))\n}\n\nprivate fun solution(num: Int): Int {\n    val str = num.toString(3)\n    val reversedStr = str.reversed()\n    return Integer.parseInt(reversedStr, 3)\n}\n\nprivate fun solution_1(num: Int): Int {\n    val str = num.toString(10)\n    val reversedStr = str.reversed()\n    return Integer.parseInt(reversedStr, 10)\n}"}
{"kt_path": "korilin__DSA-kt__b96ba1b/src/main/kotlin/sort_algorithm/quickSort.kt", "Qwen2.5-Coder-3B-Instruct": "class QuickSortKt {\n\n    companion object {\n\n        fun quickSort(arr: IntArray) {\n            checkNotNull(arr) { \"array must not be null\" }\n            quickSortInner(arr, 0, arr.size - 1)\n        }\n\n        private fun quickSortInner(arr: IntArray, low: Int, high: Int) {\n            if (low < high) {\n                val pivotIndex = partition(arr, low, high)\n                quickSortInner(arr, low, pivotIndex - 1)\n                quickSortInner(arr, pivotIndex + 1, high)\n            }\n        }\n\n        private fun partition(arr: IntArray, low: Int, high: Int): Int {\n            var i = low\n            var j = high\n            val pivot = arr[high]\n\n            while (i < j) {\n                while (i < j && arr[i] <= pivot) {\n                    i++\n                }\n                while (i < j && arr[j] > pivot) {\n                    j--\n                }\n                if (i < j) {\n                    swap(arr, i, j)\n                }\n            }\n\n            swap(arr, i, high)\n            return i\n        }\n\n        private fun swap(arr: IntArray, i: Int, j: Int) {\n            val temp = arr[i]\n            arr[i] = arr[j]\n            arr[j] = temp\n        }\n    }\n}"}
{"kt_path": "gardnerdickson__advent-of-code-2015__4a23ab3/src/day_10.kt", "Qwen2.5-Coder-3B-Instruct": "class Day10 {\n    companion object INSTANCE\n\n    fun part1(input: String): Int {\n        // Implementation of part1 goes here\n        return input.length\n    }\n\n    fun part2(input: String): Int {\n        // Implementation of part2 goes here\n        return input.count { it.isUpperCase() }\n    }\n}\n\nfun main(args: Array<String>) {\n    val input = \"1113222113\"\n    println(\"Part 1: ${Day10.INSTANCE.part1(input)}\")\n    println(\"Part 2: ${Day10.INSTANCE.part2(input)}\")\n}"}
{"kt_path": "gardnerdickson__advent-of-code-2015__4a23ab3/src/day_2.kt", "Qwen2.5-Coder-3B-Instruct": "import java.io.File\n\nobject Day2 {\n    fun part1(input: String): Int {\n        // Implement part 1 logic here\n        return 0\n    }\n\n    fun part2(input: String): Int {\n        // Implement part 2 logic here\n        return 0\n    }\n}\n\nfun main(args: Array<String>) {\n    val input = File(\"res/day_2_input.txt\").readText()\n    val part1Result = Day2.part1(input)\n    println(\"Part 1: $part1Result\")\n\n    val part2Result = Day2.part2(input)\n    println(\"Part 2: $part2Result\")\n}"}
{"kt_path": "gardnerdickson__advent-of-code-2015__4a23ab3/src/day_3.kt", "Qwen2.5-Coder-3B-Instruct": "class Day3 {\n    companion object {\n        fun part1(input: String): Int {\n            // Implementation of part1 goes here\n            return 0\n        }\n\n        fun part2(input: String): Int {\n            // Implementation of part2 goes here\n            return 0\n        }\n    }\n}\n\nfun main(args: Array<String>) {\n    val input = \"res/day_3_input.txt\"\n    val part1Result = Day3.part1(input)\n    println(\"Part 1: $part1Result\")\n\n    val part2Result = Day3.part2(input)\n    println(\"Part 2: $part2Result\")\n}"}
{"kt_path": "antop-dev__algorithm__9a3e762/src/main/kotlin/kr/co/programmers/P161988.kt", "Qwen2.5-Coder-3B-Instruct": "class P161988 {\n    fun solution(arr: IntArray): Long {\n        val sequence = \"sequence\"\n        Intrinsics.checkNotNullParameter(arr, sequence)\n        val max1 = max(arr, 1)\n        val max2 = max(arr, -1)\n        return Math.max(max1, max2)\n    }\n\n    private fun max(arr: IntArray, offset: Int): Long {\n        val length = arr.size\n        val result = LongArray(length)\n        var index = 0\n        while (index < length) {\n            result[index] = arr[index] * offset\n            index++\n        }\n        return result.maxOrNull() ?: 0L\n    }\n}"}
{"kt_path": "alexjlockwood__bees-and-bombs-compose__0d7a86b/app/src/main/java/com/alexjlockwood/beesandbombs/demos/utils/MathUtils.kt", "Qwen2.5-Coder-3B-Instruct": "object MathUtilsKt {\n    val PI = 3.141592653589793f\n    val TWO_PI = PI * 2f\n    val HALF_PI = PI / 2f\n\n    fun dist(x1: Float, y1: Float, x2: Float, y2: Float): Float {\n        return sqrt((x2 - x1).pow(2) + (y2 - y1).pow(2))\n    }\n\n    fun lerp(a: Float, b: Float, t: Float): Float {\n        return a + (b - a) * t\n    }\n\n    fun map(value: Float, inMin: Float, inMax: Float, outMin: Float, outMax: Float): Float {\n        return ((value - inMin) / (inMax - inMin)) * (outMax - outMin) + outMin\n    }\n\n    fun toDegrees(radians: Float): Float {\n        return radians * 180f / PI\n    }\n\n    fun ease(t: Float): Float {\n        return 3f * t * t - 2f * t * t * t\n    }\n\n    fun ease(t: Float, b: Float): Float {\n        return if (t < 0.5f) {\n            2f * t * t * t\n        } else {\n            -2f * t * t * t + 4f * t * t - 1f\n        }\n    }\n}"}
{"kt_path": "chengw315__daily-study__501b881/letcode/src/main/java/daily/LeetCodeLCP13.kt", "Qwen2.5-Coder-3B-Instruct": "class SolutionLCP13 {\n    fun minimalSteps(strings: Array<String>): Int {\n        // Implement the logic for minimalSteps here\n        return 0 // Placeholder return value\n    }\n}\n\nfun main() {\n    val solution = SolutionLCP13()\n    println(solution.minimalSteps(arrayOf(\"S#O\", \"M..\", \"M.T\")))\n    println(solution.minimalSteps(arrayOf(\"S#O\", \"M#\", \"M.T\")))\n    println(solution.minimalSteps(arrayOf(\"S#O\", \"M..\", \"M..\")))\n}"}
{"kt_path": "rajatenzyme__Coding-Journey__65a0570/Algo_Ds_Notes-master/Algo_Ds_Notes-master/Floyd_Warshall_Algorithm/Floyd_Warshall_Algorithm.kt", "Qwen2.5-Coder-3B-Instruct": "class FloydWarshall {\n    companion object INSTANCE\n\n    fun doCalcs(graph: Array<IntArray>, n: Int) {\n        for (k in 0 until n) {\n            for (i in 0 until n) {\n                for (j in 0 until n) {\n                    graph[i][j] = Math.min(graph[i][j], graph[i][k] + graph[k][j])\n                }\n            }\n        }\n    }\n}\n\nfun main(args: Array<String>) {\n    val graph = arrayOf(\n        intArrayOf(0, 3, 8, Integer.MAX_VALUE),\n        intArrayOf(Integer.MAX_VALUE, 0, Integer.MAX_VALUE, 1),\n        intArrayOf(7, Integer.MAX_VALUE, 0, Integer.MAX_VALUE),\n        intArrayOf(2, Integer.MAX_VALUE, 6, 0)\n    )\n    val n = graph.size\n    FloydWarshall.INSTANCE.doCalcs(graph, n)\n    println(\"Shortest paths:\")\n    for (i in 0 until n) {\n        for (j in 0 until n) {\n            print(\"${graph[i][j]} \")\n        }\n        println()\n    }\n}"}
{"kt_path": "brunorene__advent_of_code_2018__0cb6814/src/main/kotlin/advent/of/code/day17/Solution.kt", "Qwen2.5-Coder-3B-Instruct": "import java.io.File\nimport kotlin.text.Regex\n\nobject SolutionKt {\n    private val input = File(\"day17.txt\")\n    private val multipleCoord = Regex(\"(x|y)=([.0-9]+)\\\\.\\\\.([.0-9]+)\")\n    private val oneCoord = Regex(\"(x|y)=([.0-9]+)\")\n\n    fun getInput(): File = input\n\n    fun getMultipleCoord(): Regex = multipleCoord\n\n    fun getOneCoord(): Regex = oneCoord\n\n    fun part1(): Int {\n        val underground = Underground(input)\n        println(underground.getClay())\n        return 1\n    }\n\n    fun part2(): Int = 2\n}"}
{"kt_path": "Simplation__OpenSourceRepository__d45feaa/算法/一维数组的动态和1480.kt", "Qwen2.5-Coder-3B-Instruct": "class OneDimensionalArraySum {\n\n    companion object {\n        @JvmStatic fun main() {\n            val nums = intArrayOf(1, 2, 3, 4, 5)\n            println(sumArr(nums, nums, 1))\n        }\n\n        @JvmStatic fun sumArr(nums: IntArray, newNums: IntArray, index: Int): Int {\n            requireNotNull(nums) { \"nums should not be null\" }\n            requireNotNull(newNums) { \"newNums should not be null\" }\n\n            if (index == 0) {\n                return nums[0]\n            }\n\n            return sumArr(nums, newNums, index - 1) + newNums[index - 1]\n        }\n    }\n}"}
{"kt_path": "jimmymorales__project-euler__e881cad/src/main/kotlin/Problem3.kt", "Qwen2.5-Coder-3B-Instruct": "fun main() {\n    val result = solution3(600851475143L)\n    println(result)\n}\n\nprivate fun solution3(n: Long): Long {\n    var num = n\n    while (num > 1) {\n        if (num % 2 == 0) {\n            num /= 2\n        } else {\n            var divisor = 3\n            while (divisor * divisor <= num) {\n                if (num % divisor == 0) {\n                    num /= divisor\n                } else {\n                    divisor += 2\n                }\n            }\n            if (num > 2) {\n                num /= num\n            }\n        }\n    }\n    return num\n}"}
{"kt_path": "age-series__ElectricalAge2__86d843f/src/main/kotlin/org/eln2/mc/data/SegmentTree.kt", "Qwen2.5-Coder-3B-Instruct": "import kotlin.jvm.internal.Intrinsics.checkNotNullParameter\n\nclass SegmentTree<T>(root: SegmentTreeNode<T>) {\n    private val root: SegmentTreeNode<T>\n\n    init {\n        checkNotNullParameter(root, \"root\")\n        this.root = root\n    }\n\n    fun queryOrNull(value: Double): T? {\n        return if (root.contains(value)) {\n            root.query(value)\n        } else {\n            null\n        }\n    }\n\n    fun query(value: Double): T {\n        val result = root.query(value)\n        if (result != null) {\n            return result\n        } else {\n            throw IllegalStateException(\"not found\")\n        }\n    }\n}"}
{"kt_path": "ykrytsyn__leetcode-in-kotlin__0acf2a6/src/main/kotlin/leetcode/UniquePaths.kt", "Qwen2.5-Coder-3B-Instruct": "class UniquePaths {\n    fun dynamicProgramming(m: Int, n: Int): Int {\n        val dp = Array(m) { IntArray(n) }\n        for (i in 0 until m) {\n            dp[i][0] = 1\n        }\n        for (j in 0 until n) {\n            dp[0][j] = 1\n        }\n        for (i in 1 until m) {\n            for (j in 1 until n) {\n                dp[i][j] = dp[i - 1][j] + dp[i][j - 1]\n            }\n        }\n        return dp[m - 1][n - 1]\n    }\n\n    fun recursive(m: Int, n: Int): Int {\n        if (m == 1 || n == 1) {\n            return 1\n        }\n        return recursive(m - 1, n) + recursive(m, n - 1)\n    }\n}"}
{"kt_path": "quincy__euler-kotlin__01d96f6/src/main/kotlin/com/quakbo/euler/Euler6.kt", "Qwen2.5-Coder-3B-Instruct": "import kotlin.sequences.*\n\nfun sumOfSquares(sequence: Sequence<Int>): Int = sequence.map { it * it }.sum()\n\nfun squareOfSums(sequence: Sequence<Int>): Int = sequence.sum().pow()\n\nfun main(args: Array<String>) {\n    val numbers = generateSequence(1) { it + 1 }.take(100)\n    println(squareOfSums(numbers) - sumOfSquares(numbers))\n}\n\nprivate fun Int.pow(): Int = this * this"}
{"kt_path": "Kirchberg__BigDataPL__b6a459a/LR7/src/main/kotlin/Task1V3.kt", "Qwen2.5-Coder-3B-Instruct": "import java.lang.StringBuilder\nimport java.util.*\n\nfun task1V3() {\n    val input = \"java android kotlin rust\"\n    val words = input.split(\" \")\n    val finder = WordChainFinder(words)\n    val longestChain = finder.findLongestWordChain()\n    val result = StringBuilder(\"Longest word chain: \")\n    result.append(longestChain.joinToString(\", \"))\n    println(result.toString())\n}\n\nclass WordChainFinder(val words: List<String>) {\n    fun findLongestWordChain(): List<String> {\n        // Implement the logic to find the longest word chain here\n        return listOf() // Placeholder for actual implementation\n    }\n}"}
{"kt_path": "fredyw__leetcode__a59d77c/src/main/kotlin/leetcode/Problem2064.kt", "Qwen2.5-Coder-3B-Instruct": "class Problem2064 {\n    fun minimizedMaximum(n: Int, quantities: IntArray): Int {\n        checkNotNull(quantities) { \"quantities cannot be null\" }\n        var maxQuantity = 1\n        for (quantity in quantities) {\n            maxQuantity = maxOf(maxQuantity, quantity)\n        }\n        var left = 1\n        var right = maxQuantity\n        while (left < right) {\n            val mid = (left + right + 1) / 2\n            if (canDistribute(n, quantities, mid)) {\n                left = mid\n            } else {\n                right = mid - 1\n            }\n        }\n        return left\n    }\n\n    private fun canDistribute(n: Int, quantities: IntArray, maxQuantity: Int): Boolean {\n        var remaining = n\n        for (quantity in quantities) {\n            remaining -= Math.min(quantity, maxQuantity)\n            if (remaining < 0) {\n                return false\n            }\n        }\n        return true\n    }\n}"}
