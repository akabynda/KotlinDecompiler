{"kt_path": "remisultan__multiarm-bandit-algorithm-kotlin__ead934d/core-bandit/src/main/kotlin/org/rsultan/bandit/algorithms/BanditAlgorithm.kt", "Qwen2.5-Coder-3B": "package org.rsultan.bandit.algorithms\n\ninterface BanditAlgorithm {\n    fun selectArm(): Int\n    fun update(arm: Int, reward: Float)\n}"}
{"kt_path": "n81ur3__kotlin-coding-challenges__fdc5941/src/main/kotlin/adventofcode2018/Day22ModeMaze.kt", "Qwen2.5-Coder-3B": "import adventofcode2018.Day22ModeMaze\n\nclass Day22ModeMaze {\n    constructor()\n}"}
{"kt_path": "n81ur3__kotlin-coding-challenges__fdc5941/src/main/kotlin/adventofcode2017/Day21FractalArt.kt", "Qwen2.5-Coder-3B": "class Day21FractalArt {\n    constructor() {\n        // Constructor implementation\n    }\n}"}
{"kt_path": "n81ur3__kotlin-coding-challenges__fdc5941/src/main/kotlin/adventofcode2017/Day03SpiralMemory.kt", "Qwen2.5-Coder-3B": "package adventofcode2017\n\nclass Day03SpiralMemory {\n    constructor()\n}"}
{"kt_path": "n81ur3__kotlin-coding-challenges__fdc5941/src/main/kotlin/adventofcode2019/Day03CrossedWires.kt", "Qwen2.5-Coder-3B": "import adventofcode2019.Day03CrossedWires\n\nclass Day03CrossedWires {\n    constructor() {\n        // Constructor implementation\n    }\n}"}
{"kt_path": "n81ur3__kotlin-coding-challenges__fdc5941/src/main/kotlin/adventofcode2018/Day04ReposeRecord.kt", "Qwen2.5-Coder-3B": "package adventofcode2018\n\nclass Day04ReposeRecord {\n    constructor() {\n        // Constructor implementation\n    }\n}"}
{"kt_path": "n81ur3__kotlin-coding-challenges__fdc5941/src/main/kotlin/adventofcode2017/Day08LikeRegisters.kt", "Qwen2.5-Coder-3B": "package adventofcode2017\n\nclass Day08LikeRegisters {\n    constructor() {\n        // Constructor implementation\n    }\n}"}
{"kt_path": "n81ur3__kotlin-coding-challenges__fdc5941/src/main/kotlin/adventofcode2018/Day11ChronalCharge.kt", "Qwen2.5-Coder-3B": "package adventofcode2018\n\nclass Day11ChronalCharge {\n    constructor()\n}"}
{"kt_path": "n81ur3__kotlin-coding-challenges__fdc5941/src/main/kotlin/adventofcode2020/Day19MonsterMessage.kt", "Qwen2.5-Coder-3B": "package adventofcode2020\n\nclass Day19MonsterMessage {\n    constructor() {\n        // Constructor implementation\n    }\n}"}
{"kt_path": "n81ur3__kotlin-coding-challenges__fdc5941/src/main/kotlin/adventofcode2017/Day07RecursiveCircus.kt", "Qwen2.5-Coder-3B": "import adventofcode2017.Day07RecursiveCircus\n\nclass Day07RecursiveCircus {\n    constructor()\n}"}
{"kt_path": "n81ur3__kotlin-coding-challenges__fdc5941/src/main/kotlin/adventofcode2019/Day12TheNbodyProblem.kt", "Qwen2.5-Coder-3B": "package adventofcode2019\n\nclass Day12TheNbodyProblem {\n    constructor()\n}"}
{"kt_path": "n81ur3__kotlin-coding-challenges__fdc5941/src/main/kotlin/adventofcode2018/Day15BeverageBandits.kt", "Qwen2.5-Coder-3B": "import adventofcode2018.Day15BeverageBandits\n\nclass Day15BeverageBandits() {\n    constructor() {\n        super()\n    }\n}"}
{"kt_path": "n81ur3__kotlin-coding-challenges__fdc5941/src/main/kotlin/adventofcode2020/Day07HandyHaversacks.kt", "Qwen2.5-Coder-3B": "import adventofcode2020.Day07HandyHaversacks\n\nfun main() {\n    val handyHaversacks = Day07HandyHaversacks()\n    // Add your logic here\n}"}
{"kt_path": "n81ur3__kotlin-coding-challenges__fdc5941/src/main/kotlin/adventofcode2018/Day07TheSumOfItsParts.kt", "Qwen2.5-Coder-3B": "package adventofcode2018\n\nclass Day07TheSumOfItsParts {\n    constructor() {\n        // Constructor implementation\n    }\n}"}
{"kt_path": "n81ur3__kotlin-coding-challenges__fdc5941/src/main/kotlin/adventofcode2017/Day25TheHaltingProblem.kt", "Qwen2.5-Coder-3B": "class Day25TheHaltingProblem {\n    constructor() {\n    }\n}"}
{"kt_path": "n81ur3__kotlin-coding-challenges__fdc5941/src/main/kotlin/adventofcode2019/Day06UniversalOrbitMap.kt", "Qwen2.5-Coder-3B": "import adventofcode2019.Day06UniversalOrbitMap\n\nclass Day06UniversalOrbitMap {\n    constructor()\n}"}
{"kt_path": "n81ur3__kotlin-coding-challenges__fdc5941/src/main/kotlin/adventofcode2019/Day10MonitoringStation.kt", "Qwen2.5-Coder-3B": "import adventofcode2019.Day10MonitoringStation\n\nclass Day10MonitoringStation {\n    constructor() {\n        // Constructor implementation\n    }\n}"}
{"kt_path": "n81ur3__kotlin-coding-challenges__fdc5941/src/main/kotlin/adventofcode2018/Day06ChronalCoordinates.kt", "Qwen2.5-Coder-3B": "import adventofcode2018.Day06ChronalCoordinates\n\nfun main() {\n    val day06 = Day06ChronalCoordinates()\n    // Additional code for the main function\n}"}
{"kt_path": "n81ur3__kotlin-coding-challenges__fdc5941/src/main/kotlin/adventofcode2020/Day21AllergenAssessment.kt", "Qwen2.5-Coder-3B": "package adventofcode2020\n\nclass Day21AllergenAssessment {\n    constructor() {\n    }\n}"}
{"kt_path": "n81ur3__kotlin-coding-challenges__fdc5941/src/main/kotlin/adventofcode2017/Day24ElectromagneticMoat.kt", "Qwen2.5-Coder-3B": "package adventofcode2017\n\nclass Day24ElectromagneticMoat {\n    constructor()\n}"}
{"kt_path": "n81ur3__kotlin-coding-challenges__fdc5941/src/main/kotlin/adventofcode2018/Day12SubterraneanSustainability.kt", "Qwen2.5-Coder-3B": "package adventofcode2018\n\nclass Day12SubterraneanSustainability {\n    constructor() {\n        // Constructor implementation\n    }\n}"}
{"kt_path": "n81ur3__kotlin-coding-challenges__fdc5941/src/main/kotlin/adventofcode2018/Day23ExperimentalEmergencyTeleportation.kt", "Qwen2.5-Coder-3B": "import adventofcode2018.Day23ExperimentalEmergencyTeleportation\n\nclass Day23ExperimentalEmergencyTeleportation {\n    constructor() {\n        // Constructor implementation\n    }\n}"}
{"kt_path": "alebedev__aoc2022__d6ba46b/src/main/kotlin/Map.kt", "Qwen2.5-Coder-3B": "import AocMap\n\nfun main(args: Array<String>) {\n    main()\n}\n\nfun main() {\n    AocMap.INSTANCE.solve()\n}"}
{"kt_path": "andrewrlee__adventOfCode2020__a9c21a6/src/main/kotlin/File09.kt", "Qwen2.5-Coder-3B": "class Challenge09 {\n    fun solve() {\n        // Your implementation here\n    }\n}\n\nfun main() {\n    Challenge09().solve()\n}\n\nfun main(args: Array<String>) {\n    main()\n}"}
{"kt_path": "andrewrlee__adventOfCode2020__a9c21a6/src/main/kotlin/File08.kt", "Qwen2.5-Coder-3B": "class Challenge08 {\n    fun solve() {\n        // Your implementation here\n    }\n}\n\nfun main() {\n    Challenge08().solve()\n}\n\nfun main(args: Array<String>) {\n    main()\n}"}
{"kt_path": "andrewrlee__adventOfCode2020__a9c21a6/src/main/kotlin/File02.kt", "Qwen2.5-Coder-3B": "class Challenge02 {\n    fun solve() {\n        // Your implementation here\n    }\n}\n\nfun main() {\n    Challenge02().solve()\n}\n\nfun main(args: Array<String>) {\n    main()\n}"}
{"kt_path": "andrewrlee__adventOfCode2020__a9c21a6/src/main/kotlin/File07.kt", "Qwen2.5-Coder-3B": "class Challenge07 {\n    fun solve() {\n        // Your implementation here\n    }\n}\n\nfun main() {\n    Challenge07().solve()\n}\n\nfun main(args: Array<String>) {\n    main()\n}"}
{"kt_path": "charlesfranciscodev__codingame__3ec8060/puzzles/kotlin/src/war/war.kt", "Qwen2.5-Coder-3B": "import kotlin.jvm.internal.Intrinsics.checkNotNullParameter\n\nclass Game {\n    fun play() {\n        // Implementation of play method\n    }\n}\n\nfun main(args: Array<String>) {\n    checkNotNullParameter(args, \"args\")\n    val game = Game()\n    game.play()\n}"}
{"kt_path": "al-volkov__spbu_2020_kotlin_homeworks__5049681/src/main/kotlin/homework_5/Task1.kt", "Qwen2.5-Coder-3B": "import kotlin.text.StringsKt.toIntOrNull\n\nfun isNumber(str: String): Boolean {\n    kotlin.jvm.internal.Intrinsics.checkNotNullParameter(str, \"<this>\")\n    return toIntOrNull(str) != null\n}"}
{"kt_path": "iafsilva__codility-lessons__5d86aef/src/main/kotlin/lesson3/FrogJmp.kt", "Qwen2.5-Coder-3B": "package lesson3\n\nclass FrogJmp {\n    fun solution(x: Int, y: Int, z: Int): Int {\n        val distance = y - x\n        val jumps = distance / z\n        val remainder = distance % z\n        return if (remainder != 0) jumps + 1 else jumps\n    }\n}"}
{"kt_path": "mikhalchenko-alexander__advent-of-kotlin-2018-week1__c483ade/src/main/kotlin/com/anahoret/pathfinding/MarkingWayOnMap.kt", "Qwen2.5-Coder-3B": "package com.anahoret.pathfinding\n\nimport kotlin.jvm.internal.Intrinsics.checkNotNullParameter\n\nobject MarkingWayOnMapKt {\n    @JvmStatic\n    fun addPath(map: String): String {\n        checkNotNullParameter(map, \"map\")\n        return Graph.INSTANCE.getMapWithPath(map)\n    }\n}"}
{"kt_path": "charlesfranciscodev__codingame__3ec8060/puzzles/kotlin/src/surface/surface.kt", "Qwen2.5-Coder-3B": "import kotlin.jvm.internal.Intrinsics.checkNotNullParameter\n\nclass SurfaceKt {\n    companion object {\n        const val LAND = 'L'\n        const val WATER = 'W'\n        const val DEFAULT_INDEX = 0\n\n        @JvmStatic\n        fun main(args: Array<String>) {\n            checkNotNullParameter(args, \"args\")\n            val grid = Grid()\n            grid.readGameInput()\n            grid.test()\n        }\n    }\n}\n\nclass Grid {\n    fun readGameInput() {\n        // Implementation for reading game input\n    }\n\n    fun test() {\n        // Implementation for testing\n    }\n}"}
{"kt_path": "andrew-suprun__AoC-2023__dd5f53e/src/main/kotlin/day03_oop/day03_oop.kt", "Qwen2.5-Coder-3B": "package day03_oop\n\nfun main(args: Array<String>) {\n    Part1(\"input.data\").run()\n    Part2(\"input.data\").run()\n}\n\nclass Part1(val input: String) {\n    fun run() {\n        // Implementation for Part1\n    }\n}\n\nclass Part2(val input: String) {\n    fun run() {\n        // Implementation for Part2\n    }\n}"}
{"kt_path": "getnahid__programing-problem-solves-kotlin__589c392/CyclicRotation.kt", "Qwen2.5-Coder-3B": "import kotlin.jvm.internal.Intrinsics.checkNotNullParameter\n\nclass CyclicRotationKt {\n\n    companion object {\n        @JvmStatic\n        fun solution(arr: IntArray, k: Int): IntArray {\n            checkNotNullParameter(arr, \"arr\")\n            val n = arr.size\n            val rotatedArray = IntArray(n)\n            var index = 0\n\n            for (i in 0 until n) {\n                rotatedArray[index] = arr[(i + k) % n]\n                index++\n            }\n\n            return rotatedArray\n        }\n    }\n}"}
{"kt_path": "linisme__LeetCodeInKotlin__4382afc/LongestPalindrome.kt", "Qwen2.5-Coder-3B": "import kotlin.jvm.internal.Intrinsics.checkNotNullParameter\n\nclass LongestPalindromeSolution {\n    fun longestPalindrome(s: String): String {\n        // Implementation of the longestPalindrome function\n        return \"\"\n    }\n}\n\nfun main(args: String) {\n    checkNotNullParameter(args, \"args\")\n    val solution = LongestPalindromeSolution()\n    val result = solution.longestPalindrome(\"abbccbbdl\")\n    println(result)\n}"}
{"kt_path": "iafsilva__codility-lessons__5d86aef/src/main/kotlin/lesson2/OddOccurrencesInArray.kt", "Qwen2.5-Coder-3B": "package lesson2\n\nclass OddOccurrencesInArray {\n    fun solution(a: IntArray): Int {\n        var result = 0\n        var index = 0\n\n        while (index < a.size) {\n            result = result xor a[index]\n            index++\n        }\n\n        return result\n    }\n}"}
{"kt_path": "jjeda__playground__5d1ee6c/src/oop/algorithm/ProgressionNextNumber.kt", "Qwen2.5-Coder-3B": "package oop.algorithm\n\nclass ProgressionNextNumber {\n    constructor() {\n        // Constructor implementation\n    }\n\n    fun solution(numbers: IntArray): Int {\n        requireNotNull(numbers) { \"numbers cannot be null\" }\n        val progressionHelper = ProgressionHelper(numbers.toList())\n        return progressionHelper.nextInt()\n    }\n}\n\nclass ProgressionHelper(private val numbers: List<Int>) {\n    fun nextInt(): Int {\n        // Implementation for finding the next number in the progression\n    }\n}"}
{"kt_path": "linisme__LeetCodeInKotlin__4382afc/LengthOfLongestSubstring.kt", "Qwen2.5-Coder-3B": "import kotlin.jvm.internal.Intrinsics.checkNotNullParameter\n\nclass LengthOfLongestSubstringSolution2 {\n    fun lengthOfLongestSubstring(s: String): Int {\n        // Implementation of the method\n    }\n}\n\nfun main(args: Array<String>) {\n    checkNotNullParameter(args, \"args\")\n    val solution = LengthOfLongestSubstringSolution2()\n    val result = solution.lengthOfLongestSubstring(\"abba\")\n    println(result)\n}"}
{"kt_path": "nschulzke__mancala-puzzle-solver__b130d3b/src/main/kotlin/Main.kt", "Qwen2.5-Coder-3B": "import kotlin.collections.setOf\n\nobject MainKt {\n    private val mancalaIndices: Set<Int> = setOf(6, 13)\n\n    fun access$getMancalaIndices$p(): Set<Int> {\n        return mancalaIndices\n    }\n}"}
{"kt_path": "sysion__DataStructureAlgorithmKt__6f9afda/TwoSumLessThanTarget.kt", "Qwen2.5-Coder-3B": "fun main() {\n    val intArray = arrayOf(10, 20, 30)\n    val target = 15\n    val result = SumTwoNumbersLessThanTarget(intArray, target)\n    println(result)\n}\n\nfun SumTwoNumbersLessThanTarget(intArray: IntArray, target: Int): Int {\n    var result = -1\n    for (i in 0 until intArray.size - 1) {\n        for (j in i + 1 until intArray.size) {\n            if (intArray[i] + intArray[j] < target) {\n                result = intArray[i] + intArray[j]\n            }\n        }\n    }\n    return result\n}"}
{"kt_path": "linisme__LeetCodeInKotlin__4382afc/FineMedianSortedArrays.kt", "Qwen2.5-Coder-3B": "import kotlin.jvm.internal.Intrinsics.checkNotNullParameter\n\nclass FindMedianSortedArraysSolution {\n    fun findMedianSortedArrays(nums1: IntArray, nums2: IntArray): Double {\n        // Implementation of the findMedianSortedArrays method\n    }\n}\n\nfun main(args: Array<String>) {\n    val solution = FindMedianSortedArraysSolution()\n    val nums1 = intArrayOf(1, 3)\n    val nums2 = intArrayOf(2)\n    val median = solution.findMedianSortedArrays(nums1, nums2)\n    println(median)\n}"}
{"kt_path": "n81ur3__kotlin-coding-challenges__fdc5941/src/main/kotlin/adventofcode2018/Day18SettlersOfTheNorthPole.kt", "Qwen2.5-Coder-3B": "package adventofcode2018\n\nimport kotlin.jvm.internal.Intrinsics.checkNotNullParameter\n\nclass Day18SettlersOfTheNorthPole {\n    constructor() {\n        // Constructor implementation\n    }\n}\n\nfun hash(list: List<List<AreaElement>>): Int {\n    checkNotNullParameter(list, \"<this>\")\n    val collection = list as Collection<List<AreaElement>>\n    var index = 0\n    var list1: List<List<AreaElement>>? = null\n    list1 = list\n    return Arrays.deepHashCode(list1)\n}"}
{"kt_path": "iafsilva__codility-lessons__5d86aef/src/main/kotlin/lesson3/PermMissingElem.kt", "Qwen2.5-Coder-3B": "package lesson3\n\nclass PermMissingElem {\n    fun solution(a: IntArray): Int {\n        kotlin.collections.ArraysKt.sort(a)\n        var index = 0\n        while (index < a.size) {\n            if (a[index] != index + 1) {\n                return index + 1\n            }\n            index++\n        }\n        return a.size + 1\n    }\n}"}
{"kt_path": "getnahid__programing-problem-solves-kotlin__589c392/OddOccurrencesInArray.kt", "Qwen2.5-Coder-3B": "import kotlin.collections.ArraysKt\nimport kotlin.internal.ProgressionUtilKt\n\nfun solution(arr: IntArray): Int {\n    ArraysKt.sort(arr)\n    val length = arr.size\n    val lastElement = ProgressionUtilKt.getProgressionLastElement(0, length - 1, 2)\n    for (i in 0 until lastElement) {\n        if (arr[i] != arr[i + 1]) {\n            return arr[i]\n        }\n    }\n    return arr[length - 1]\n}"}
{"kt_path": "rupeshsasne__coursera-algorithms-part1__341634c/classroom/src/main/kotlin/com/radix2/algorithms/week3/SortingLinkedList.kt", "Qwen2.5-Coder-3B": "import kotlin.jvm.internal.Intrinsics.checkNotNullParameter\n\nclass LinkedList {\n    private var head: Node? = null\n\n    fun add(value: Comparable<*>) {\n        val newNode = Node(value)\n        newNode.next = head\n        head = newNode\n    }\n\n    fun reverseRecurrsive() {\n        head = reverseRecurrsive(head)\n    }\n\n    private fun reverseRecurrsive(node: Node?): Node? {\n        if (node == null || node.next == null) {\n            return node\n        }\n        val reversedNext = reverseRecurrsive(node.next)\n        node.next = null\n        reversedNext?.next = node\n        return reversedNext\n    }\n\n    private class Node<T>(val value: T) {\n        var next: Node<T>? = null\n    }\n}\n\nfun main(args: Array<String>) {\n    Intrinsics.checkNotNullParameter(args, \"args\")\n    val list = LinkedList()\n    for (i in 0..10) {\n        list.add(i)\n    }\n    list.reverseRecurrsive()\n    println(list)\n}"}
{"kt_path": "boris920308__HoOne__8881468/hoon/HoonAlgorithm/src/main/kotlin/boj/week02/recursive_function/FibonacciSequence5.kt", "Qwen2.5-Coder-3B": "import java.util.Scanner\n\nfun main() {\n    val scanner = Scanner(System.`in`)\n    val n = scanner.nextInt()\n    println(fibonacci(n))\n}\n\nfun fibonacci(n: Int): Int {\n    return if (n <= 1) n else fibonacci(n - 1) + fibonacci(n - 2)\n}"}
{"kt_path": "Codextor__kotlin-codes__68b75a7/src/main/kotlin/PerfectSquares.kt", "Qwen2.5-Coder-3B": "fun numSquares(n: Int): Int {\n    val dp = IntArray(n + 1) { Int.MAX_VALUE }\n    dp[0] = 0\n\n    for (i in 1..n) {\n        for (j in 1..Math.sqrt(i.toDouble()).toInt()) {\n            dp[i] = Math.min(dp[i], dp[i - j * j] + 1)\n        }\n    }\n\n    return dp[n]\n}"}
{"kt_path": "Laomedeia__Java8InAction__0dcd843/src/main/java/leetcode/a167_twoSumInputSortArray_SIMPLE/Solution.kt", "Qwen2.5-Coder-3B": "package leetcode.a167_twoSumInputSortArray_SIMPLE\n\nclass Solution {\n    fun twoSum(numbers: IntArray, target: Int): IntArray {\n        var left = 0\n        var right = numbers.size - 1\n\n        while (left < right) {\n            val sum = numbers[left] + numbers[right]\n            if (sum == target) {\n                return intArrayOf(left + 1, right + 1)\n            } else if (sum < target) {\n                left++\n            } else {\n                right--\n            }\n        }\n\n        return intArrayOf()\n    }\n}"}
{"kt_path": "ariannysOronoz__tutorialKotlin__a779f54/CombinacionesPalabras/src/main/java/Main.kt", "Qwen2.5-Coder-3B": "import kotlin.jvm.internal.Intrinsics.checkNotNullParameter\n\nclass Permutation {\n    fun findPermutation(str: String, start: Int, end: Int) {\n        if (start == end) {\n            println(str)\n        } else {\n            for (i in start..end) {\n                val newStr = str.toCharArray()\n                newStr[start] = newStr[i]\n                newStr[i] = str[start]\n                findPermutation(String(newStr), start + 1, end)\n            }\n        }\n    }\n}\n\nfun main(args: Array<String>) {\n    val permutation = Permutation()\n    val str = \"CARACOL\"\n    val length = str.length\n    permutation.findPermutation(str, 0, length - 1)\n    println(\"caracol\")\n    permutation.findPermutation(\"caracol\", 0, length - 1)\n}"}
{"kt_path": "scientificCommunity__blog-sample__36e291c/algorithms/src/main/kotlin/org/baichuan/sample/algorithms/leetcode/middle/MaxArea.kt", "Qwen2.5-Coder-3B": "package org.baichuan.sample.algorithms.leetcode.middle\n\nimport kotlin.math.min\n\nclass MaxArea {\n    fun maxArea(height: IntArray): Int {\n        var left = 0\n        var right = height.size - 1\n        var maxArea = 0\n\n        while (left < right) {\n            val minHeight = min(height[left], height[right])\n            maxArea = maxOf(maxArea, minHeight * (right - left))\n\n            if (height[left] < height[right]) {\n                left++\n            } else {\n                right--\n            }\n        }\n\n        return maxArea\n    }\n}"}
{"kt_path": "boris920308__HoOne__8881468/hoon/HoonAlgorithm/src/main/kotlin/programmers/lv01/Lv1_70128.kt", "Qwen2.5-Coder-3B": "fun main() {\n    val arr1 = arrayOf(1, 2, 3, 4)\n    val arr2 = arrayOf(1, -1, 0, 2)\n    val result = solution(arr1, arr2)\n    println(result)\n}\n\nprivate fun solution(arr1: IntArray, arr2: IntArray): Int {\n    var sum = 0\n    for (i in arr1.indices) {\n        sum += arr1[i] * arr2[i]\n    }\n    return sum\n}"}
{"kt_path": "kotler-dev__kotlin-leetcode__0659e72/src/main/kotlin/exercise/easy/id121/Solution121.kt", "Qwen2.5-Coder-3B": "import kotlin.jvm.internal.Intrinsics.checkNotNullParameter\n\nclass Solution121 {\n    fun maxProfit(prices: IntArray): Int {\n        checkNotNullParameter(prices, \"prices\")\n        val length = prices.size\n        if (length < 2) {\n            return 0\n        }\n        var maxProfit = 0\n        var minPrice = Int.MAX_VALUE\n        var currentProfit = 0\n        var i = 0\n        while (i < length) {\n            val price = prices[i]\n            if (price < minPrice) {\n                minPrice = price\n            }\n            currentProfit = price - minPrice\n            if (currentProfit > maxProfit) {\n                maxProfit = currentProfit\n            }\n            i++\n        }\n        return maxProfit\n    }\n}"}
{"kt_path": "marc-bouvier-katas__Kotlin_EduTools_Advent_of_Code_2021__12cf74c/Day 5/Part 1/src/Task.kt", "Qwen2.5-Coder-3B": "import kotlin.jvm.internal.Intrinsics.checkNotNullParameter\n\nclass TaskKt {\n    companion object {\n        @JvmStatic\n        fun overlaps(ventsLines: Array<String>): Int {\n            checkNotNullParameter(ventsLines, \"ventsLines\")\n            val lines = Lines()\n            for (line in ventsLines) {\n                val lineOfVent = LineOfVent.Companion.fromString(line)\n                val line = Line.Companion.fromLineOfVent(lineOfVent)\n                lines.mergeWith(line)\n            }\n            return lines.overlaps()\n        }\n    }\n}\n\ndata class Lines(\n    private val map: Map<String, Line>,\n    private val size: Int,\n    private val marker: Any\n) {\n    fun mergeWith(other: Line) {\n        // Implementation not provided\n    }\n\n    fun overlaps(): Int {\n        // Implementation not provided\n        return 0\n    }\n}\n\ndata class LineOfVent(\n    private val line: String\n) {\n    companion object {\n        fun fromString(line: String): LineOfVent {\n            // Implementation not provided\n            return LineOfVent(line)\n        }\n    }\n}\n\ndata class Line(\n    private val lineOfVent: LineOfVent\n) {\n    companion object {\n        fun fromLineOfVent(lineOfVent: LineOfVent): Line {\n            // Implementation not provided\n            return Line(lineOfVent)\n        }\n    }\n}"}
{"kt_path": "Laomedeia__Java8InAction__0dcd843/src/main/java/leetcode/a392_isSubSequence_HARD/Solution.kt", "Qwen2.5-Coder-3B": "package leetcode.a392_isSubSequence_HARD\n\nimport kotlin.jvm.internal.Intrinsics.checkNotNullParameter\n\nclass Solution {\n    fun isSubsequence(s: String, t: String): Boolean {\n        checkNotNullParameter(s, \"s\")\n        checkNotNullParameter(t, \"t\")\n\n        if (s.length == 0) {\n            return true\n        }\n\n        var indexS = 0\n        var indexT = 0\n\n        while (indexT < t.length) {\n            if (s[indexS] == t[indexT]) {\n                indexS++\n            }\n            indexT++\n        }\n\n        return indexS == s.length\n    }\n}"}
{"kt_path": "nickperov__Algorithms__6696f5d/fibonacci/src/main/kotlin/com/nickperov/stud/algorithms/fibonacci/FibonacciLargeGenerator.kt", "Qwen2.5-Coder-3B": "import java.math.BigInteger\n\nobject FibonacciLargeGeneratorKt {\n    @JvmStatic\n    fun main() {\n        println(\"Hello, large Fibonacci numbers\")\n        val generator = FibonacciLargeTailRecursiveOptimisedGenerator()\n        println(generator.calculate(1000000))\n    }\n}\n\nclass FibonacciLargeTailRecursiveOptimisedGenerator {\n    fun calculate(n: Int): BigInteger {\n        return calculateTailRecursive(BigInteger.ONE, BigInteger.ZERO, n)\n    }\n\n    private tailrec fun calculateTailRecursive(a: BigInteger, b: BigInteger, n: Int): BigInteger {\n        return if (n == 0) b else calculateTailRecursive(b, a + b, n - 1)\n    }\n}"}
{"kt_path": "TonnyL__Windary__39f85cd/Kotlin/src/UniqueBinarySearchTrees.kt", "Qwen2.5-Coder-3B": "class UniqueBinarySearchTrees {\n    fun numTrees(n: Int): Int {\n        val memo = Array(n + 1) { IntArray(n + 1) { -1 } }\n\n        fun countTrees(left: Int, right: Int): Int {\n            if (left > right) return 1\n            if (memo[left][right] != -1) return memo[left][right]\n\n            var result = 0\n            for (i in left..right) {\n                result += countTrees(left, i - 1) * countTrees(i + 1, right)\n            }\n            memo[left][right] = result\n            return result\n        }\n\n        return countTrees(1, n)\n    }\n}"}
{"kt_path": "quincy__euler-kotlin__01d96f6/src/main/kotlin/com/quakbo/euler/Euler4.kt", "Qwen2.5-Coder-3B": "import kotlin.text.StringsKt.reversed\n\nfun isPalindrome(num: Int): Boolean {\n    val numStr = num.toString()\n    return numStr == reversed(numStr)\n}\n\nfun main(args: Array<String>) {\n    for (i in 999 downTo 100) {\n        for (j in 999 downTo 100) {\n            val product = i * j\n            if (isPalindrome(product)) {\n                println(product)\n            }\n        }\n    }\n}"}
{"kt_path": "getupminaaa__Algorithm__01187e2/Algorithm/src/main/kotlin/programmers/level1/personalInfoCollectionValidityPeriod.kt", "Qwen2.5-Coder-3B": "class Solution {\n    fun solution(date: String, a: Array<String>, b: Array<String>, c: Array<String>): Int {\n        // Implementation logic goes here\n    }\n}\n\nfun main() {\n    val solution = Solution()\n    solution.solution(\"2022.05.19\", arrayOf(\"A 6\", \"B 12\", \"C 3\"), arrayOf(\"2021.05.02\", \"2021.07.01\", \"2022.02.19\", \"2022.02.20\"), arrayOf(\"2022.05.19\"))\n}"}
{"kt_path": "iafsilva__codility-lessons__5d86aef/src/main/kotlin/lesson1/BinaryGap.kt", "Qwen2.5-Coder-3B": "package lesson1\n\nclass BinaryGap {\n    fun solution(number: Int): Int {\n        var maxGap = 0\n        var currentGap = 0\n        var previousBit = 0\n        var currentBit = 0\n\n        val binaryString = number.toString(2)\n\n        for (bit in binaryString) {\n            currentBit = bit.toInt()\n            if (currentBit == 1) {\n                if (previousBit == 0) {\n                    currentGap = 0\n                } else {\n                    currentGap++\n                }\n                previousBit = currentBit\n            } else {\n                if (currentBit == 0) {\n                    currentGap++\n                }\n            }\n            if (currentGap > maxGap) {\n                maxGap = currentGap\n            }\n        }\n\n        return maxGap\n    }\n}"}
{"kt_path": "zys0909__CodeLabs__869c7c2/src/com/leecode/array/Code1.kt", "Qwen2.5-Coder-3B": "package com.leecode.array\n\nimport kotlin.jvm.internal.Intrinsics.checkNotNullParameter\n\nfun missingNumber1(nums: IntArray): Int {\n    checkNotNullParameter(nums, \"nums\")\n    var i = 0\n    var j = 0\n    while (j < nums.size) {\n        if (nums[j] != i) {\n            return i\n        }\n        i++\n        j++\n    }\n    return i\n}\n\nfun missingNumber2(nums: IntArray): Int {\n    checkNotNullParameter(nums, \"nums\")\n    var i = 0\n    var j = nums.size - 1\n    while (i < j) {\n        val mid = (i + j) / 2\n        if (nums[mid] == mid) {\n            i = mid + 1\n        } else {\n            j = mid\n        }\n    }\n    return i\n}"}
{"kt_path": "ykrytsyn__leetcode-in-kotlin__0acf2a6/src/main/kotlin/leetcode/ArrangingCoins.kt", "Qwen2.5-Coder-3B": "package leetcode\n\nclass ArrangingCoins {\n    fun bruteForce(n: Int): Int {\n        var sum = 0\n        var count = 1\n        while (count <= n) {\n            sum += count\n            if (sum > n) {\n                return count - 1\n            }\n            count++\n        }\n        return count - 1\n    }\n\n    fun binarySearch(n: Int): Int {\n        var left = 0L\n        var right = n.toLong()\n        while (left <= right) {\n            val mid = (left + right) / 2\n            val sum = mid * (mid + 1) / 2\n            if (sum == n.toLong()) {\n                return mid.toInt()\n            } else if (sum < n.toLong()) {\n                left = mid + 1\n            } else {\n                right = mid - 1\n            }\n        }\n        return right.toInt()\n    }\n}"}
{"kt_path": "mayabot__mynlp__b980da3/mynlp/src/main/java/com/mayabot/nlp/module/nwd/ValueObjects.kt", "Qwen2.5-Coder-3B": "import kotlin.jvm.internal.Intrinsics.checkNotNullParameter\n\nclass ValueObjectsKt {\n\n    companion object {\n        @JvmStatic\n        fun addTo(map: HashMap<Char, IntCount>, key: Char, value: Int) {\n            checkNotNullParameter(map, \"<this>\")\n            val mapValue = map.get(key)\n            if (mapValue != null) {\n                val intCount = mapValue as IntCount\n                intCount.value += value\n            } else {\n                val intCount = IntCount()\n                map.put(key, intCount)\n                intCount.value = value\n            }\n        }\n    }\n}\n\ndata class IntCount(val value: Int = 0) {\n    fun setValue(newValue: Int) {\n        value = newValue\n    }\n}"}
{"kt_path": "jjrodcast__CompetitiveProblems__a91868c/leetcode/UniquePathsTwo.kt", "Qwen2.5-Coder-3B": "import java.io.PrintStream\n\nclass Solution {\n    fun uniquePathsWithObstacles(obstacleGrid: Array<IntArray>): Int {\n        val m = obstacleGrid.size\n        val n = obstacleGrid[0].size\n        val dp = Array(m) { IntArray(n) }\n        dp[0][0] = if (obstacleGrid[0][0] == 0) 1 else 0\n\n        for (i in 0 until m) {\n            for (j in 0 until n) {\n                if (obstacleGrid[i][j] == 1) {\n                    dp[i][j] = 0\n                } else {\n                    if (i > 0) dp[i][j] += dp[i - 1][j]\n                    if (j > 0) dp[i][j] += dp[i][j - 1]\n                }\n            }\n        }\n\n        return dp[m - 1][n - 1]\n    }\n}\n\nfun main() {\n    val solution = Solution()\n    val obstacleGrid = arrayOf(\n        intArrayOf(0, 0, 0),\n        intArrayOf(0, 1, 0),\n        intArrayOf(0, 0, 0)\n    )\n    val result = solution.uniquePathsWithObstacles(obstacleGrid)\n    println(result)\n}"}
{"kt_path": "boris920308__HoOne__8881468/hoon/HoonAlgorithm/src/main/kotlin/programmers/lv01/Lv1_77884.kt", "Qwen2.5-Coder-3B": "fun main() {\n    val result = solution(13, 17)\n    println(result)\n}\n\nprivate fun solution(a: Int, b: Int): Int {\n    var count = 0\n    var current = a\n    while (current <= b) {\n        if (countDivisors(current) % 2 == 0) {\n            count += current\n        }\n        current++\n    }\n    return count\n}\n\nprivate fun countDivisors(n: Int): Int {\n    var divisorCount = 0\n    for (i in 1..Math.sqrt(n.toDouble()).toInt()) {\n        if (n % i == 0) {\n            divisorCount += 2\n        }\n    }\n    return divisorCount\n}"}
{"kt_path": "Codextor__kotlin-codes__68b75a7/src/main/kotlin/PartitionArrayForMaximumSum.kt", "Qwen2.5-Coder-3B": "fun maxSumAfterPartitioning(arr: IntArray, k: Int): Int {\n    val n = arr.size\n    val dp = Array(n + 1) { IntArray(n + 1) }\n    for (i in 1..n) {\n        for (j in 1..k) {\n            var max = 0\n            for (l in 0 until j) {\n                max = Math.max(max, arr[i - 1 - l])\n            }\n            dp[i][j] = Math.max(dp[i - 1][j], dp[i - 1][j - 1] + max * j)\n        }\n    }\n    return dp[n][k]\n}"}
{"kt_path": "scientificCommunity__blog-sample__36e291c/algorithms/src/main/kotlin/org/baichuan/sample/algorithms/leetcode/simple/interview/MajorityElement.kt", "Qwen2.5-Coder-3B": "package org.baichuan.sample.algorithms.leetcode.simple.interview\n\nclass MajorityElement {\n    fun majorityElement(nums: IntArray): Int {\n        var count = 0\n        var candidate = 0\n        for (num in nums) {\n            if (count == 0) {\n                candidate = num\n                count++\n            } else if (num == candidate) {\n                count++\n            } else {\n                count--\n            }\n        }\n        return candidate\n    }\n}"}
{"kt_path": "rhavran__ProjectEuler__1115674/src/Utils.kt", "Qwen2.5-Coder-3B": "import java.util.Map\n\nobject UtilsKt {\n    @JvmStatic\n    fun dividers(number: Long): Long {\n        val map = PrimeFactorization.INSTANCE.primeFactors(number)\n        var result = 1L\n        for ((_, value) in map.entries) {\n            result *= value.longValue() + 1\n        }\n        return result\n    }\n\n    @JvmStatic\n    fun sequenceSumStartingFrom(start: Long, end: Long): Long {\n        return sumFromTo(start, end)\n    }\n\n    @JvmStatic\n    fun sumFromTo(start: Long, end: Long): Long {\n        return (end - start + 1).toLong() * (start + end) / 2\n    }\n}\n\nclass PrimeFactorization {\n    companion object {\n        val INSTANCE = PrimeFactorization()\n    }\n\n    fun primeFactors(number: Long): Map<Long, Long> {\n        // Implementation of prime factors calculation\n        TODO(\"Not yet implemented\")\n    }\n}"}
{"kt_path": "jimmymorales__project-euler__e881cad/src/main/kotlin/Problem4.kt", "Qwen2.5-Coder-3B": "fun main() {\n    val largestPalindrome = largestPalindrome()\n    println(largestPalindrome)\n}\n\nfun largestPalindrome(): Int {\n    var largest = 0\n    for (i in 999 downTo 100) {\n        for (j in 999 downTo 100) {\n            val product = i * j\n            if (isPalindrome(product) && product > largest) {\n                largest = product\n            }\n        }\n    }\n    return largest\n}\n\nfun isPalindrome(num: Int): Boolean {\n    return num == reverse(num)\n}\n\nfun reverse(num: Int): Int {\n    var reversed = 0\n    var original = num\n    while (original > 0) {\n        reversed = reversed * 10 + original % 10\n        original /= 10\n    }\n    return reversed\n}"}
{"kt_path": "Codextor__kotlin-codes__68b75a7/src/main/kotlin/PalindromicSubstrings.kt", "Qwen2.5-Coder-3B": "import kotlin.jvm.internal.Intrinsics.checkNotNullParameter\n\nfun countSubstrings(s: String): Int {\n    checkNotNullParameter(s, \"s\")\n    var count = 0\n    var left = 0\n    var right = 0\n    for (i in 0 until s.length) {\n        left = i\n        right = i\n        count += countSubstringsWithCenter(s, left, right)\n        left = i\n        right = i + 1\n        count += countSubstringsWithCenter(s, left, right)\n    }\n    return count\n}\n\nprivate fun countSubstringsWithCenter(s: String, left: Int, right: Int): Int {\n    var count = 0\n    while (left >= 0 && right < s.length && s[left] == s[right]) {\n        count++\n        left--\n        right++\n    }\n    return count\n}"}
{"kt_path": "antop-dev__algorithm__9a3e762/src/main/kotlin/kr/co/programmers/P12952.kt", "Qwen2.5-Coder-3B": "class P12952 {\n    fun solution(n: Int): Int {\n        return dfs(IntArray(n), n)\n    }\n\n    private fun dfs(arr: IntArray, n: Int): Int {\n        if (n == 0) {\n            return 1\n        }\n        var count = 0\n        for (i in 0 until n) {\n            arr[i] = i\n            if (valid(arr, n)) {\n                count += dfs(arr, n - 1)\n            }\n        }\n        return count\n    }\n\n    private fun valid(arr: IntArray, n: Int): Boolean {\n        for (i in 0 until n - 1) {\n            if (arr[i] == arr[n - 1] || Math.abs(arr[i] - arr[n - 1]) == Math.abs(i - (n - 1))) {\n                return false\n            }\n        }\n        return true\n    }\n}"}
{"kt_path": "ILIYANGERMANOV__algorithms__4abe4b5/Algorithms/src/main/kotlin/MaxSubArray.kt", "Qwen2.5-Coder-3B": "class MaxSubArray {\n    constructor()\n\n    fun maxSubArray(nums: IntArray): Int {\n        if (nums.isEmpty()) {\n            return 0\n        }\n\n        var maxSum = nums[0]\n        var currentSum = nums[0]\n\n        for (i in 1 until nums.size) {\n            currentSum = Math.max(nums[i], currentSum + nums[i])\n            maxSum = Math.max(maxSum, currentSum)\n        }\n\n        return maxSum\n    }\n}"}
{"kt_path": "AlBovo__Compiti__56a3131/src/main/kotlin/segtree.kt", "Qwen2.5-Coder-3B": "import java.lang.Integer\n\nfun main() {\n    val arr = arrayOf(2, 4, 2, 1, 3, 6, 5)\n    val tree = SegmentTree(arr)\n\n    println(tree.getSum(0, 4))\n}\n\nclass SegmentTree(val arr: Array<Int>) {\n    private val tree: Array<Int> = Array(4 * arr.size) { 0 }\n\n    init {\n        buildTree(0, arr.size - 1, 0)\n    }\n\n    private fun buildTree(left: Int, right: Int, index: Int) {\n        if (left == right) {\n            tree[index] = arr[left]\n            return\n        }\n\n        val mid = (left + right) / 2\n        buildTree(left, mid, 2 * index + 1)\n        buildTree(mid + 1, right, 2 * index + 2)\n        tree[index] = tree[2 * index + 1] + tree[2 * index + 2]\n    }\n\n    fun getSum(left: Int, right: Int): Int {\n        return getSumHelper(left, right, 0, arr.size - 1, 0)\n    }\n\n    private fun getSumHelper(left: Int, right: Int, treeLeft: Int, treeRight: Int, index: Int): Int {\n        if (left <= treeLeft && treeRight <= right) {\n            return tree[index]\n        }\n\n        if (treeRight < left || treeLeft > right) {\n            return 0\n        }\n\n        val mid = (treeLeft + treeRight) / 2\n        return getSumHelper(left, right, treeLeft, mid, 2 * index + 1) +\n               getSumHelper(left, right, mid + 1, treeRight, 2 * index + 2)\n    }\n}"}
{"kt_path": "3mtee__exercism-kotlin__6e3eb88/complex-numbers/src/main/kotlin/ComplexNumbers.kt", "Qwen2.5-Coder-3B": "import kotlin.math.*\n\nclass ComplexNumber(val real: Double, val imag: Double) {\n    operator fun times(other: ComplexNumber): ComplexNumber {\n        return ComplexNumber(\n            real * other.real - imag * other.imag,\n            real * other.imag + imag * other.real\n        )\n    }\n}\n\nfun exponential(c: ComplexNumber): ComplexNumber {\n    val real = c.real\n    val imag = c.imag\n    kotlin.jvm.internal.Intrinsics.checkNotNullParameter(c, \"c\")\n\n    if (real == 0.0) {\n        return ComplexNumber(1.0, 0.0)\n    } else {\n        val cos = cos(imag)\n        val sin = sin(imag)\n        return ComplexNumber(\n            cos * pow(2.718281828459045, real),\n            sin * pow(2.718281828459045, real)\n        )\n    }\n}"}
{"kt_path": "perihanmirkelam__ProjectEuler__a24ac44/src/main/kotlin/P014_LongestCollatzSequence.kt", "Qwen2.5-Coder-3B": "fun p14() {\n    var maxCount = 0\n    var maxStart = 0\n    for (start in 1..1000000) {\n        var count = 0\n        var current = start\n        while (current != 1) {\n            if (current % 2 == 0) {\n                current /= 2\n            } else {\n                current = current * 3 + 1\n            }\n            count++\n        }\n        if (count > maxCount) {\n            maxCount = count\n            maxStart = start\n        }\n    }\n    println(\"A14: $maxStart\")\n}"}
{"kt_path": "iafsilva__codility-lessons__5d86aef/src/main/kotlin/lesson2/CyclicRotation.kt", "Qwen2.5-Coder-3B": "package lesson2\n\nclass CyclicRotation {\n    fun solution(a: IntArray, k: Int): IntArray {\n        if (a.isEmpty() || k == 0) {\n            return a\n        }\n\n        val n = a.size\n        val m = k % n\n\n        if (m == 0) {\n            return a\n        }\n\n        val deque = ArrayDeque<Int>()\n        for (i in 0 until n) {\n            deque.addLast(a[i])\n        }\n\n        for (i in 0 until m) {\n            deque.addFirst(deque.removeLast())\n        }\n\n        return deque.toIntArray()\n    }\n}"}
{"kt_path": "boris920308__HoOne__8881468/hoon/HoonAlgorithm/src/main/kotlin/programmers/lv01/Lv1_12912.kt", "Qwen2.5-Coder-3B": "fun main() {\n    println(solution(3, 5))\n    println(solution(3, 3))\n    println(solution(5, 3))\n}\n\nprivate fun solution(a: Int, b: Int): Long {\n    var sum = 0L\n    if (a <= b) {\n        for (i in a..b) {\n            sum += i\n        }\n    } else {\n        for (i in b..a) {\n            sum += i\n        }\n    }\n    return sum\n}\n\nprivate fun secondSolution(a: Int, b: Int): Long {\n    return if (a <= b) {\n        (a..b).sumOf { it.toLong() }\n    } else {\n        (b..a).sumOf { it.toLong() }\n    }\n}"}
{"kt_path": "darian-catalin-cucer__divide-and-conquer-algorithms__1cea70d/kt.kt", "Qwen2.5-Coder-3B": "import kotlin.jvm.internal.Intrinsics.checkNotNullParameter\n\nfun quickSort(arr: IntArray, start: Int, end: Int) {\n    checkNotNullParameter(arr, \"arr\")\n    if (start < end) {\n        val pivotIndex = partition(arr, start, end)\n        quickSort(arr, start, pivotIndex - 1)\n        quickSort(arr, pivotIndex + 1, end)\n    }\n}\n\nfun partition(arr: IntArray, start: Int, end: Int): Int {\n    checkNotNullParameter(arr, \"arr\")\n    val pivot = arr[end]\n    var i = start\n    for (j in start until end) {\n        if (arr[j] < pivot) {\n            arr[i] = arr[j]\n            i++\n        }\n    }\n    arr[i] = pivot\n    return i\n}"}
{"kt_path": "TonnyL__Windary__39f85cd/Kotlin/src/ThreeSumClosest.kt", "Qwen2.5-Coder-3B": "class ThreeSumClosest {\n    fun threeSumClosest(nums: IntArray, target: Int): Int {\n        nums.sort()\n        var closestSum = nums[0] + nums[1] + nums[2]\n        var left = 0\n        var right = nums.size - 1\n\n        while (left < right) {\n            val currentSum = nums[left] + nums[right]\n            if (currentSum == target) {\n                return target\n            }\n\n            if (Math.abs(currentSum - target) < Math.abs(closestSum - target)) {\n                closestSum = currentSum\n            }\n\n            if (currentSum < target) {\n                left++\n            } else {\n                right--\n            }\n        }\n\n        return closestSum\n    }\n}"}
{"kt_path": "Javran__leetcode__f3899fe/bulb-switcher/Solution.kt", "Qwen2.5-Coder-3B": "class Solution {\n    companion object {\n        fun bulbSwitch(n: Int): Int {\n            return (Math.sqrt(n.toDouble())).toInt()\n        }\n    }\n\n    companion object {\n        @JvmStatic\n        fun main(args: Array<String>) {\n            println(bulbSwitch(10))\n        }\n    }\n}"}
{"kt_path": "TonnyL__Windary__39f85cd/Kotlin/src/NextPermutation.kt", "Qwen2.5-Coder-3B": "class NextPermutation {\n    fun nextPermutation(nums: IntArray) {\n        val n = nums.size\n        var i = n - 2\n        while (i >= 0 && nums[i] >= nums[i + 1]) {\n            i--\n        }\n        if (i >= 0) {\n            var j = n - 1\n            while (j >= 0 && nums[j] <= nums[i]) {\n                j--\n            }\n            swap(nums, i, j)\n        }\n        reverse(nums, i + 1, n - 1)\n    }\n\n    private fun swap(nums: IntArray, i: Int, j: Int) {\n        val temp = nums[i]\n        nums[i] = nums[j]\n        nums[j] = temp\n    }\n\n    private fun reverse(nums: IntArray, start: Int, end: Int) {\n        var i = start\n        var j = end\n        while (i < j) {\n            swap(nums, i, j)\n            i++\n            j--\n        }\n    }\n}"}
{"kt_path": "boris920308__HoOne__8881468/hoon/HoonAlgorithm/src/main/kotlin/programmers/lv01/Lv1_12940.kt", "Qwen2.5-Coder-3B": "fun main() {\n    val result1 = solution(3, 12)\n    println(result1.toList())\n    \n    val result2 = solution(2, 5)\n    println(result2.toList())\n}\n\nfun solution(a: Int, b: Int): List<Int> {\n    val gcd = findGCD(a, b)\n    val lcm = findLCM(a, b)\n    return listOf(gcd, lcm)\n}\n\nfun findGCD(a: Int, b: Int): Int {\n    return if (b != 0) findGCD(b, a % b) else a\n}\n\nfun findLCM(a: Int, b: Int): Int {\n    return a * b / findGCD(a, b)\n}"}
{"kt_path": "JiangKlijna__leetcode-learning__65a1348/kt/001 Two Sum/TwoSum.kt", "Qwen2.5-Coder-3B": "class TwoSum {\n    fun twoSum(numbers: IntArray, target: Int): IntArray {\n        val map = HashMap<Int, Int>()\n        for (i in numbers.indices) {\n            val complement = target - numbers[i]\n            if (map.containsKey(complement)) {\n                return intArrayOf(map[complement]!!, i)\n            }\n            map[numbers[i]] = i\n        }\n        return intArrayOf()\n    }\n}"}
{"kt_path": "rupeshsasne__coursera-algorithms-part1__341634c/classroom/src/main/kotlin/com/radix2/algorithms/week1/UnionFind.kt", "Qwen2.5-Coder-3B": "package com.radix2.algorithms.week1\n\nimport kotlin.jvm.internal.Intrinsics.checkNotNullParameter\n\nclass UnionFindKt {\n    companion object {\n        @JvmStatic\n        fun main(args: String) {\n            checkNotNullParameter(args, \"args\")\n            val uf = WeightedQuickUnionWithPathCompressionUF(10)\n            uf.union(4, 3)\n            uf.union(3, 8)\n            uf.union(6, 5)\n            uf.union(9, 4)\n            uf.union(2, 1)\n            uf.union(5, 0)\n            uf.union(7, 2)\n            uf.union(6, 1)\n            uf.union(7, 3)\n        }\n    }\n}\n\nclass WeightedQuickUnionWithPathCompressionUF(val size: Int) {\n    private val parent: IntArray\n    private val rank: IntArray\n\n    init {\n        parent = IntArray(size) { it }\n        rank = IntArray(size) { 0 }\n    }\n\n    fun union(p: Int, q: Int) {\n        val rootP = find(p)\n        val rootQ = find(q)\n        if (rootP == rootQ) return\n        if (rank[rootP] < rank[rootQ]) {\n            parent[rootP] = rootQ\n        } else {\n            parent[rootQ] = rootP\n            if (rank[rootP] == rank[rootQ]) {\n                rank[rootP]++\n            }\n        }\n    }\n\n    fun find(p: Int): Int {\n        if (parent[p] != p) {\n            parent[p] = find(parent[p])\n        }\n        return parent[p]\n    }\n}"}
{"kt_path": "boris920308__HoOne__8881468/hoon/HoonAlgorithm/src/main/kotlin/programmers/lv01/Lv1_68935.kt", "Qwen2.5-Coder-3B": "fun main() {\n    println(solution(45))\n}\n\nprivate fun solution(num: Int): Int {\n    return num.toString().reversed().toInt(3)\n}\n\nprivate fun solution_1(num: Int): Int {\n    return num.toString().reversed().toInt(10)\n}"}
{"kt_path": "korilin__DSA-kt__b96ba1b/src/main/kotlin/sort_algorithm/quickSort.kt", "Qwen2.5-Coder-3B": "package sort_algorithm\n\nimport kotlin.Unit\nimport kotlin.jvm.internal.Intrinsics.checkNotNullParameter\n\nfun quickSort(arr: IntArray) {\n    checkNotNullParameter(arr, \"array\")\n    quickSortInner(arr, 0, arr.size - 1)\n}\n\nprivate fun quickSortInner(arr: IntArray, start: Int, end: Int) {\n    if (start < end) {\n        val partitionIndex = partition(arr, start, end)\n        quickSortInner(arr, start, partitionIndex - 1)\n        quickSortInner(arr, partitionIndex + 1, end)\n    }\n}\n\nprivate fun partition(arr: IntArray, start: Int, end: Int): Int {\n    var i = start\n    var j = start\n    var pivot = arr[end]\n\n    while (j < end) {\n        if (arr[j] < pivot) {\n            arr[i] = arr[j]\n            i++\n        }\n        j++\n    }\n\n    arr[i] = pivot\n    return i\n}"}
{"kt_path": "gardnerdickson__advent-of-code-2015__4a23ab3/src/day_10.kt", "Qwen2.5-Coder-3B": "import kotlin.jvm.internal.Intrinsics.checkNotNullParameter\n\nobject Day_10Kt {\n    @JvmStatic\n    fun main(args: String) {\n        checkNotNullParameter(args, \"args\")\n        val input = \"1113222113\"\n        val part1Result = Day10.part1(input)\n        println(\"Part 1: $part1Result\")\n        val part2Result = Day10.part2(input)\n        println(\"Part 2: $part2Result\")\n    }\n}"}
{"kt_path": "gardnerdickson__advent-of-code-2015__4a23ab3/src/day_2.kt", "Qwen2.5-Coder-3B": "import kotlin.jvm.internal.Intrinsics.checkNotNullParameter\n\nclass Day_2Kt {\n    companion object {\n        @JvmStatic\n        fun main(args: String) {\n            checkNotNullParameter(args, \"args\")\n            val input = \"res/day_2_input.txt\"\n            val part1Result = Day2.INSTANCE.part1(input)\n            println(\"Part 1: $part1Result\")\n            val part2Result = Day2.INSTANCE.part2(input)\n            println(\"Part 2: $part2Result\")\n        }\n    }\n}"}
{"kt_path": "gardnerdickson__advent-of-code-2015__4a23ab3/src/day_3.kt", "Qwen2.5-Coder-3B": "import kotlin.jvm.internal.Intrinsics.checkNotNullParameter\n\nobject Day_3Kt {\n    @JvmStatic\n    fun main(args: Array<String>) {\n        checkNotNullParameter(args, \"args\")\n        val input = \"res/day_3_input.txt\"\n        val part1Result = Day3.INSTANCE.part1(input)\n        println(\"Part 1: $part1Result\")\n        val part2Result = Day3.INSTANCE.part2(input)\n        println(\"Part 2: $part2Result\")\n    }\n}"}
{"kt_path": "antop-dev__algorithm__9a3e762/src/main/kotlin/kr/co/programmers/P161988.kt", "Qwen2.5-Coder-3B": "import kotlin.math.max\n\nclass P161988 {\n    fun solution(sequence: IntArray): Long {\n        return max(sequence)\n    }\n\n    private fun max(sequence: IntArray, start: Int = 0): Long {\n        val length = sequence.size\n        val maxArray = LongArray(length)\n        var index = start\n        while (index < length) {\n            maxArray[index] = sequence[index] * (index - start) + max(maxArray[index - 1], sequence[index - 1])\n            index++\n        }\n        return maxArray[length - 1]\n    }\n}"}
{"kt_path": "alexjlockwood__bees-and-bombs-compose__0d7a86b/app/src/main/java/com/alexjlockwood/beesandbombs/demos/utils/MathUtils.kt", "Qwen2.5-Coder-3B": "object MathUtilsKt {\n    val PI = 3.141592653589793f\n    val TWO_PI = 6.283185307179586f\n    val HALF_PI = 1.5707963267948966f\n\n    fun dist(x1: Float, y1: Float, x2: Float, y2: Float): Float {\n        return (x2 - x1).toDouble().pow(2.0) + (y2 - y1).toDouble().pow(2.0).sqrt().toFloat()\n    }\n\n    fun lerp(start: Float, end: Float, t: Float): Float {\n        return start + (end - start) * t\n    }\n\n    fun map(value: Float, inMin: Float, inMax: Float, outMin: Float, outMax: Float): Float {\n        return (value - inMin) / (inMax - inMin) * (outMax - outMin) + outMin\n    }\n\n    fun toDegrees(radians: Float): Float {\n        return radians.toDouble().toDegrees().toFloat()\n    }\n\n    fun ease(t: Float): Float {\n        return if (t >= 0.5f) {\n            0.5f * t * t * t * t * t\n        } else {\n            0.5f * t * t * t * t * t\n        }\n    }\n\n    fun ease(t: Float, t2: Float): Float {\n        return if (t >= 0.5f) {\n            0.5f * t * t * t * t * t\n        } else {\n            0.5f * t * t * t * t * t\n        }\n    }\n}"}
{"kt_path": "chengw315__daily-study__501b881/letcode/src/main/java/daily/LeetCodeLCP13.kt", "Qwen2.5-Coder-3B": "class SolutionLCP13 {\n    fun minimalSteps(strings: Array<String>): Int {\n        // Implementation of the minimalSteps function\n    }\n}\n\nfun main() {\n    val solution = SolutionLCP13()\n    val strings1 = arrayOf(\"S#O\", \"M..\", \"M.T\")\n    val result1 = solution.minimalSteps(strings1)\n    println(\"Result 1: $result1\")\n\n    val strings2 = arrayOf(\"S#O\", \"M#\", \"M.T\")\n    val result2 = solution.minimalSteps(strings2)\n    println(\"Result 2: $result2\")\n}"}
{"kt_path": "rajatenzyme__Coding-Journey__65a0570/Algo_Ds_Notes-master/Algo_Ds_Notes-master/Floyd_Warshall_Algorithm/Floyd_Warshall_Algorithm.kt", "Qwen2.5-Coder-3B": "import kotlin.jvm.internal.Intrinsics.checkNotNullParameter\n\nclass FloydWarshall {\n    companion object {\n        @JvmStatic\n        fun main(args: Array<String>) {\n            checkNotNullParameter(args, \"args\")\n            val n = 5\n            val matrix = Array(n) { IntArray(n) }\n            matrix[0][0] = 3\n            matrix[0][1] = 3\n            matrix[0][2] = 3\n            matrix[0][3] = 3\n            matrix[0][4] = 3\n            matrix[1][0] = 3\n            matrix[1][1] = 3\n            matrix[1][2] = 3\n            matrix[1][3] = 3\n            matrix[1][4] = 3\n            matrix[2][0] = 3\n            matrix[2][1] = 3\n            matrix[2][2] = 3\n            matrix[2][3] = 3\n            matrix[2][4] = 3\n            matrix[3][0] = 3\n            matrix[3][1] = 3\n            matrix[3][2] = 3\n            matrix[3][3] = 3\n            matrix[3][4] = 3\n            matrix[4][0] = 3\n            matrix[4][1] = 3\n            matrix[4][2] = 3\n            matrix[4][3] = 3\n            matrix[4][4] = 3\n            val matrix2 = Array(n) { IntArray(n) }\n            matrix2[0][0] = 3\n            matrix2[0][1] = 3\n            matrix2[0][2] = 3\n            matrix2[0][3] = 3\n            matrix2[0][4] = 3\n            matrix2[1][0] = 3\n            matrix2[1][1] = 3\n            matrix2[1][2] = 3\n            matrix2[1][3] = 3\n            matrix2[1][4] = 3\n            matrix2[2][0] = 3\n            matrix2[2][1] = 3\n            matrix2[2][2] = 3\n            matrix2[2][3] = 3\n            matrix2[2][4] = 3\n            matrix2[3][0] = 3\n            matrix2[3][1] = 3\n            matrix2[3][2] = 3\n            matrix2[3][3] = 3\n            matrix2[3][4] = 3\n            matrix2[4][0] = 3\n            matrix2[4][1] = 3\n            matrix2[4][2] = 3\n            matrix2[4][3] = 3\n            matrix2[4][4] = 3\n            val matrix3 = Array(n) { IntArray(n) }\n            matrix3[0][0] = 3\n            matrix3[0][1] = 3\n            matrix3[0][2] = 3\n            matrix3[0][3] = 3\n            matrix3[0][4] = 3\n            matrix3[1][0] = 3\n            matrix3[1][1] = 3\n            matrix3[1][2] = 3\n            matrix3[1][3] = 3\n            matrix3[1][4] = 3\n            matrix3[2][0] = 3\n            matrix3[2][1] = 3\n            matrix3[2][2] = 3\n            matrix3[2][3] = 3\n            matrix3[2][4] = 3\n            matrix3[3][0] = 3\n            matrix3[3][1] = 3\n            matrix3[3][2] = 3\n            matrix3[3][3] = 3\n            matrix3[3][4] = 3\n            matrix3[4][0] = 3\n            matrix3[4][1] = 3\n            matrix3[4][2] = 3\n            matrix3[4][3] = 3\n            matrix3[4][4] = 3\n            val matrix4 = Array(n) { IntArray(n) }\n            matrix4[0][0] = 3\n            matrix4[0][1] = 3\n            matrix4[0][2] = 3\n            matrix4[0][3] = 3\n            matrix4[0][4] = 3\n            matrix4[1][0] = 3\n            matrix4[1][1] = 3\n            matrix4[1][2] = 3\n            matrix4[1][3] = 3\n            matrix4[1][4] = 3\n            matrix4[2][0] = 3\n            matrix4[2][1] = 3\n            matrix4[2][2] = 3\n            matrix4[2][3] = 3\n            matrix4[2][4] = 3\n            matrix4[3][0] = 3\n            matrix4[3][1] = 3\n            matrix4[3][2] = 3\n            matrix4[3][3] = 3\n            matrix4[3][4] = 3\n            matrix4[4][0] = 3\n            matrix4[4][1] = 3\n            matrix4[4][2] = 3\n            matrix4[4][3] = 3\n            matrix4[4][4] = 3\n            val matrix5 = Array(n) { IntArray(n) }\n            matrix5[0][0] = 3\n            matrix5[0][1] = 3\n            matrix5[0][2] = 3\n            matrix5[0][3] = 3\n            matrix5[0][4] = 3\n            matrix5[1][0] = 3\n            matrix5[1][1] = 3\n            matrix5[1][2] = 3\n            matrix5[1][3] = 3\n            matrix5[1][4] = 3\n            matrix5[2][0] = 3\n            matrix5[2][1] = 3\n            matrix5[2][2] = 3\n            matrix5[2][3] = 3\n            matrix5[2][4] = 3\n            matrix5[3][0] = 3\n            matrix5[3][1] = 3\n            matrix5[3][2] = 3\n            matrix5[3][3] = 3\n            matrix5[3][4] = 3\n            matrix5[4][0] = 3\n            matrix5[4][1] = 3\n            matrix5[4][2] = 3\n            matrix5[4][3] = 3\n            matrix5[4][4] = 3\n            val matrix6 = Array(n) { IntArray(n) }\n            matrix6[0][0] = 3\n            matrix6[0][1] = 3\n            matrix6[0][2] = 3\n            matrix6[0][3] = 3\n            matrix6[0][4] = 3\n            matrix6[1][0] = 3\n            matrix6[1][1] = 3\n            matrix6[1][2] = 3\n            matrix6[1][3] = 3\n            matrix6[1][4] = 3\n            matrix6[2][0] = 3\n            matrix6[2][1] = 3\n            matrix6[2][2] = 3\n            matrix6[2][3] = 3\n            matrix6[2][4] = 3\n            matrix6[3][0] = 3\n            matrix6[3][1] = 3\n            matrix6[3][2] = 3\n            matrix6[3][3] = 3\n            matrix6[3][4] = 3\n            matrix6[4][0] = 3\n            matrix6[4][1] = 3\n            matrix6[4][2] = 3\n            matrix6[4][3] = 3\n            matrix6[4][4] = 3\n            val matrix7 = Array(n) { IntArray(n) }\n            matrix7[0][0] = 3\n            matrix7[0][1] = 3\n            matrix7[0][2] = 3\n            matrix7[0][3] = 3\n            matrix7[0][4] = 3\n            matrix7[1][0] = 3\n            matrix7[1][1] = 3\n            matrix7[1][2] = 3\n            matrix7[1][3] ="}
{"kt_path": "brunorene__advent_of_code_2018__0cb6814/src/main/kotlin/advent/of/code/day17/Solution.kt", "Qwen2.5-Coder-3B": "import java.io.File\nimport kotlin.text.Regex\n\nobject SolutionKt {\n    private val input = File(\"day17.txt\")\n    private val multipleCoord = Regex(\"(x|y)=([.0-9]+)\\\\.\\\\.([.0-9]+)\")\n    private val oneCoord = Regex(\"(x|y)=([.0-9]+)\")\n\n    fun getInput(): File {\n        return input\n    }\n\n    fun getMultipleCoord(): Regex {\n        return multipleCoord\n    }\n\n    fun getOneCoord(): Regex {\n        return oneCoord\n    }\n\n    fun part1(): Int {\n        val underground = Underground(input)\n        println(underground.getClay())\n        return 1\n    }\n\n    fun part2(): Int {\n        return 2\n    }\n}"}
{"kt_path": "Simplation__OpenSourceRepository__d45feaa/算法/一维数组的动态和1480.kt", "Qwen2.5-Coder-3B": "import kotlin.jvm.internal.Intrinsics.checkNotNullParameter\n\nclass 一维数组的动态和1480Kt {\n    companion object {\n        @JvmStatic\n        fun main() {\n            val nums = intArrayOf(1, 2, 3, 4, 5)\n            val newNums = arrayOfNulls<Int>(nums.size)\n            for (i in nums.indices) {\n                newNums[i] = nums[i]\n            }\n            println(newNums.joinToString())\n        }\n\n        @JvmStatic\n        fun sumArr(nums: IntArray, newNums: IntArray, index: Int): Int {\n            checkNotNullParameter(nums, \"nums\")\n            checkNotNullParameter(newNums, \"newNums\")\n            return if (index == 0) {\n                newNums[0] = nums[0]\n                nums[0]\n            } else {\n                newNums[index] = nums[index] + sumArr(nums, newNums, index - 1)\n                newNums[index]\n            }\n        }\n    }\n}"}
{"kt_path": "jimmymorales__project-euler__e881cad/src/main/kotlin/Problem3.kt", "Qwen2.5-Coder-3B": "import java.lang.Math.sqrt\n\nfun main() {\n    val result = solution3(600851475143L)\n    println(result)\n}\n\nprivate fun solution3(n: Long): Long {\n    var num = n\n    var divisor = 2L\n    while (num % divisor == 0L) {\n        num /= divisor\n    }\n    divisor = 3L\n    while (num > 1L) {\n        while (num % divisor == 0L) {\n            num /= divisor\n        }\n        divisor += 2\n        if (num % divisor == 0L) {\n            num /= divisor\n        }\n    }\n    return divisor\n}"}
{"kt_path": "age-series__ElectricalAge2__86d843f/src/main/kotlin/org/eln2/mc/data/SegmentTree.kt", "Qwen2.5-Coder-3B": "package org.eln2.mc.data\n\nimport kotlin.jvm.internal.Intrinsics.checkNotNullParameter\n\nclass SegmentTree<T>(root: SegmentTreeNode<T>) {\n    private val root: SegmentTreeNode<T> = root\n\n    fun queryOrNull(value: Double): T? {\n        if (!root.contains(value)) {\n            return null\n        }\n        return root.query(value)\n    }\n\n    fun query(value: Double): T {\n        val result = root.query(value)\n        if (result != null) {\n            return result\n        } else {\n            throw IllegalStateException(\"Value not found\")\n        }\n    }\n}\n\nclass SegmentTreeNode<T> {\n    fun contains(value: Double): Boolean {\n        // Implementation for contains method\n    }\n\n    fun query(value: Double): T {\n        // Implementation for query method\n    }\n}"}
{"kt_path": "ykrytsyn__leetcode-in-kotlin__0acf2a6/src/main/kotlin/leetcode/UniquePaths.kt", "Qwen2.5-Coder-3B": "class UniquePaths {\n    fun dynamicProgramming(m: Int, n: Int): Int {\n        val dp = Array(m) { IntArray(n) }\n        dp[0][0] = 1\n\n        for (i in 0 until m) {\n            for (j in 0 until n) {\n                if (i > 0) {\n                    dp[i][j] += dp[i - 1][j]\n                }\n                if (j > 0) {\n                    dp[i][j] += dp[i][j - 1]\n                }\n            }\n        }\n\n        return dp[m - 1][n - 1]\n    }\n\n    fun recursive(m: Int, n: Int): Int {\n        if (m == 1 || n == 1) {\n            return 1\n        }\n        if (m == 2 && n == 2) {\n            return 2\n        }\n        return recursive(m - 1, n) + recursive(m, n - 1)\n    }\n}"}
{"kt_path": "quincy__euler-kotlin__01d96f6/src/main/kotlin/com/quakbo/euler/Euler6.kt", "Qwen2.5-Coder-3B": "import kotlin.sequences.*\n\nfun main(args: Array<String>) {\n    val sequence = generateSequence(1) { it + 1 }.take(100)\n    val sumOfSquares = sequence.sumOf { it * it }\n    val squareOfSums = sequence.sumOf { it } * sequence.sumOf { it }\n    val result = squareOfSums - sumOfSquares\n    println(result)\n}\n\nfun sumOfSquares(sequence: Sequence<Int>): Int {\n    return sequence.sumOf { it * it }\n}\n\nfun main$lambda$1(n: Int): Int {\n    return n + 1\n}\n\nfun sumOfSquares$lambda$0(n: Int): Int {\n    return n * n\n}"}
{"kt_path": "Kirchberg__BigDataPL__b6a459a/LR7/src/main/kotlin/Task1V3.kt", "Qwen2.5-Coder-3B": "import kotlin.text.StringsKt\n\nfun task1V3() {\n    val words = \"java android kotlin rust\"\n    val wordList = words.split(\" \")\n    val wordChainFinder = WordChainFinder(wordList)\n    val longestWordChain = wordChainFinder.findLongestWordChain()\n    val longestWordChainString = longestWordChain.joinToString(\", \", \"Longest word chain: \")\n    println(longestWordChainString)\n}\n\nclass WordChainFinder(val words: List<String>) {\n    fun findLongestWordChain(): List<String> {\n        // Implementation of findLongestWordChain method\n    }\n}"}
{"kt_path": "fredyw__leetcode__a59d77c/src/main/kotlin/leetcode/Problem2064.kt", "Qwen2.5-Coder-3B": "import kotlin.math.max\n\nclass Problem2064 {\n    fun minimizedMaximum(n: Int, quantities: IntArray): Int {\n        var maxQuantity = 0\n        for (quantity in quantities) {\n            maxQuantity = max(maxQuantity, quantity)\n        }\n\n        var left = 1\n        var right = maxQuantity\n        while (left < right) {\n            val mid = left + (right - left) / 2\n            if (canDistribute(n, quantities, mid)) {\n                right = mid\n            } else {\n                left = mid + 1\n            }\n        }\n        return left\n    }\n\n    private fun canDistribute(n: Int, quantities: IntArray, quantity: Int): Boolean {\n        var count = 0\n        for (q in quantities) {\n            count += q / quantity\n            if (q % quantity != 0) {\n                count++\n            }\n        }\n        return count <= n\n    }\n}"}
